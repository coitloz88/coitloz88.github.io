[ { "title": "웹 백엔드 2-4 Servlet", "url": "/posts/backend-6/", "categories": "Back-end", "tags": "web, backend, tutorial", "date": "2022-07-26 23:39:40 +0900", "snippet": "본 글은 네이버 부스트 코스: 웹 백엔드 코스를 공부하며 정리한 글입니다.다만 해당 코스가 순수 백엔드 공부용으로 제작된 것이 아니라 풀스택 강의의 일부를 재사용했기 때문에 강의 순서가 맞지 않는 경우에는 부스트 코스 순서와 일치하지 않을 수 있습니다.1. Servlet이란?Java Web ApplicationWAS에 설치(deploy)되어 동작하는 웹 어플리케이션이다. HTML, CSS, 이미지, 자바로 작성된 클래스(Servlet, package, 인터페이스 등), 각종 설정 파일이 포함된다.Servlet자바 웹 어플리케이션의 구성요소 중 동적인 처리를 하는 프로그램의 역할을 수행하며, 클라이언트의 Request에 대해 동적으로 작동하는 웹 어플리케이션 컴포넌트이다.. 즉, WAS에 동작하는 JAVA 클래스로 이해할 수 있다. Servlet은 HttpServlet 클래스를 상속받는다.Servlet과 JSP로부터 최상의 결과를 얻기 위해서는 웹 페이지 개발 시 JSP와 Servlet을 조화롭게 사용가능해야 한다.서블릿은 서버에서 실행되다가 웹 브라우저에서 요청을 하면 해당 기능을 수행한 후 웹 브라우저에 결과를 전송한다. 쉽게 예를들면 로그인 시도를 할 때, 서버가 클라이언트에서 입력되는 아이디와 비밀번호를 확인하고 결과를 응답하는데 이러한 역할을 수행하는 것이 서블릿이다.클라이언트가 웹 서버에 Request를 보내면 웹 서버는 해당 Request를 Tomcat과 같은 WAS에 위임한다. 그러면 WAS는 각 Request에 해당하는 Servlet을 실행하고, 결과를 반환(Response)하여 클라이언트에게 전송한다.References 및 이미지 출처 https://www.boostcourse.org/web326/lecture/58930?isDesc=false" }, { "title": "웹 백엔드 2-3 웹 개발환경 설정", "url": "/posts/backend-5/", "categories": "Back-end", "tags": "web, backend, tutorial", "date": "2022-07-26 00:14:30 +0900", "snippet": "본 글은 네이버 부스트 코스: 웹 백엔드 코스를 공부하며 정리한 글입니다.다만 해당 코스가 순수 백엔드 공부용으로 제작된 것이 아니라 풀스택 강의의 일부를 재사용했기 때문에 강의 순서가 맞지 않는 경우에는 부스트 코스 순서와 일치하지 않을 수 있습니다.Apache TomcatApache Tomcat은 Web Application Server의 일종이다. 컴퓨터에 운영체제를 설치해야 컴퓨터를 사용할 수 있는 것처럼, 자바를 이용하여 작성된 웹 어플리케이션은 WAS가 있어야만 실행할 수 있다. 이때 가장 많이 사용되는 WAS가 아파치 톰캣이라고 할 수 있다.톰캣은 여기서 다운로드 받을 수 있다. 부스트 코스에서는 8을 다운받았지만 나는 이전과 마찬가지로 IntelliJ, Tomcat9를 사용할 예정이다.HelloWorld!자바 웹 어플리케이션에서 Hello World!를 출력해보자☺나의 경우 IntelliJ, Tomcat9, Servlet 4.0.1을 사용중인데, IntelliJ에서 오른쪽 마우스 &amp;gt; new…에서 Servlet을 새로 생성할 수가 없었다.ㅜㅜ 그런데 우선 첫번째로는 main 폴더 하위에 java 폴더(package)를 직접 생성한 뒤(참고), 생성된 해당 java 폴더에서 오른쪽 마우스를 클릭하고 Open Module Settings &amp;gt; Facets &amp;gt; Web &amp;gt; Source Root 체크를 해주고 Reload를 해주었더니 해결되었다(참고).References 및 이미지 출처 https://www.boostcourse.org/web326/lecture/58930?isDesc=false" }, { "title": "웹 백엔드 2-2 Browser, 웹서버, WAS", "url": "/posts/backend-4/", "categories": "Back-end", "tags": "web, backend, tutorial", "date": "2022-07-25 10:11:00 +0900", "snippet": "본 글은 네이버 부스트 코스: 웹 백엔드 코스를 공부하며 정리한 글입니다.다만 해당 코스가 순수 백엔드 공부용으로 제작된 것이 아니라 풀스택 강의의 일부를 재사용했기 때문에 강의 순서가 맞지 않는 경우에는 부스트 코스 순서와 일치하지 않을 수 있습니다.서버에서 전송한 데이터는 클라이언트의 Browser에 도착한다. Browser에는 데이터를 해석해주는 parser와 데이터를 화면에 표현해주는 렌더링 엔진이 포함되어 있다.Browser1. High level structure of Browser브라우저의 main component는 다음과 같다.2. Rendering engines렌더링 엔진은 네트워킹 계층에서 Request된 문서의 내용을 가져온다. (일반적으로 8kB의 chunk로 수행된다.)3. Main flow HTML을 파싱하여 DOM tree를 구성 Render tree를 구성 Render tree의 레이아웃 프로세스 Render tree를 PaintingWebKit main flow는 다음과 같다.Parsing - generalDocument를 파싱하는 것은 코드가 사용할 수 있는 구조로 변환하는 것이다. 즉, 토큰 단위로 잘라 syntax tree를 만들면, 그 트리에 따라 값의 처리가 이루어지게 된다.4. HTML ParserHTML Parser는 HTML 마크업을 트리로 파싱하는 역할을 수행한다. 파싱된 결과 트리는 attribute 노드와 DOM 요소로 이루어진 트리가 된다. 이를 브라우저가 처리하게 된다.5. CSSCSS 역시 key와 value로 구성된 구조이다.p, div,, .error 등을 셀렉터라고 하며, 괄호 안의 요소를 선언(Declaration)이라고 한다.Web Server웹 브라우저는 URL 주소에 해당하는 웹 서버에 연결하고, 해당 주소에서 볼 수 있는 내용을 읽어들여서 사용자에게 보여주게 된다. 웹 브라우저의 요청을 받아 HTML 문서나 오브젝트를 반환하는 웹 서버에 대해 알아보자.웹 서버란? 웹 서버란, 웹 서버 소프트웨어 및 해당 소프트웨어가 동작하는 컴퓨터를 말한다. 클라이언트가 요청하는 HTML 문서나 각종 리소스를 전달한다. 일반적으로 HTTP 프로토콜을 기반으로 하여 클라이언트의 요청을 서비스한다. 웹 브라우저나 웹 크롤러가 요청하는 리소스는 컴퓨터에 저장된 정적 데이터 혹은 동적 결과가 될 수 있다. 정적 데이터란, 이미지, HTML 파일, CSS 파일, JavaScript 파일과 같이 컴퓨터에 저장되어 있는 파일을 의미한다. 동적 데이터란, 웹 서버에 의해 실행되는 프로그램에 의해 만들어지는 결과를 말한다. Apache, Nginx, Microsoft IIS 등이 많이 사용된다.웹 서버와 웹 브라우저웹 브라우저를 통해 www.naver.com라는 웹 서버에 접속한다고 가정해보자. 해당 주소에서 기본으로 보이는 HTML 문서를 요청하면, 웹 서버는 사용자가 요청한 HTML 문서를 웹 브라우저에 전달한다. 브라우저는 서버로부터 전송받은 HTML 무너를 읽어들여 해석하기 시작한다. HTML 문서를 알맞게 보여주기 위해 필요한 이미지, CSS, JavaScript와 같은 리소스에 대해 URL을 추출해내고 웹 서버에 동시에 여러 요청을 보낸다. 웹 서버는 동시에 전송된 요청을 받아들여 다시 웹 브라우저에 응답을 보낸다. 웹 브라우저는 해석된 HTML 문서와 읽어들인 여러 응답을 하나로 합쳐 그 결과를 화면에 보여준다(렌더링).WASWAS는 Web Application Server의 약자로, 일종의 미들웨어이자 웹 클라이언트(보통 웹 브라우저)의 요청 중 일반적으로 웹 어플리케이션이 동작하도록 지원하는 역할을 수행한다. MiddleWare: 클라이언트 쪽에 비즈니스 로직이 많은 경우, 클라이언트 관리(배포 등)로 인해 비용이 많이 발생하게 되는 문제가 생길 수 있다. 따라서 비즈니스 로직을 클라이언트와 DBMS 사이의 미들웨어 서버에서 동작하도록 함으로써 클라이언트는 입출력만 담당하도록 한다. Web Application Server: Database 조회나 이 외의 다양한 로직 처리를 요구하는 동적 콘텐츠를 제공하기 위해 만들어지는 Application Server며, MiddleWare이다. Web Server와 Web Container의 역할이 결합되어있다. 웹 서버 vs. WAS: WAS도 보통 자체적으로 웹 서버 기능을 내장하고 있으며, WAS의 웹 서버도 정적인 콘텐츠를 처리하는 데 있어서 성능상 큰 차이가 없다. 하지만 자원 이용의 효율성 및 장애 극복, 배포 및 유지보수의 편의성을 위해, 또한 규모가 커질수록 웹 서버와 WAS를 구분한다. References 및 이미지 출처 https://www.boostcourse.org/web326/lecture/58930?isDesc=false https://web.dev/howbrowserswork/ https://developer.mozilla.org/ko/docs/Web/Performance/How_browsers_work" }, { "title": "웹 백엔드 2-1 Web 개발의 이해", "url": "/posts/backend-3/", "categories": "Back-end", "tags": "web, backend, tutorial", "date": "2022-07-25 09:25:00 +0900", "snippet": "본 글은 네이버 부스트 코스: 웹 백엔드 코스를 공부하며 정리한 글입니다.다만 해당 코스가 순수 백엔드 공부용으로 제작된 것이 아니라 풀스택 강의의 일부를 재사용했기 때문에 강의 순서가 맞지 않는 경우에는 부스트 코스 순서와 일치하지 않을 수 있습니다.1. 웹의 동작: HTTP 프로토콜 이해클라이언트 - 서버 모델 Client 서비스를 사용하는 사용자 일반적으로 웹에서는 서버와 연결된 모든 디바이스와 디바이스에서 이용하는 웹에 접근하는 소프트웨어를 지칭한다. e.g. 브라우저 Server 클라이언트에게 네트워크를 통해 서비스 및 데이터를 제공하는 컴퓨터로, 클라이언트의 요청(request)을 받아 처리하고, 클라이언트에게 다시 응답(response)를 보낸다. Message pattern Request/Response Pattern: 클라이언트가 Request를 보내고, Server는 요청을 받으면 반드시 Response를 보낸다. 클라이언트와 서버는 일정하게 정해진 어플리케이션 규약에 의거하여 Request와 Response를 주고 받는다. 웹 브라우저와 웹 서버 간에는 주로 Http가 사용된다. HTTP(Hypertext Transfer Protocol)란? 서버와 클라이언트가 인터넷 상에서 데이터를 주고받기 위한 Protocol이다. Server/Client 모델을 따른다. 불특정 다수를 대상으로 하는 서비스에 적합하며, 클라이언트와 서버가 계속 연결된 형태가 아니므로 최대 연결 수보다 훨씬 많은 Request와 Response를 처리할 수 있다. 연결을 끊어버리므로 클라이언트의 이전 상황을 알 수 없으며(Stateless), 정보를 유지하기 위해 Cookie와 같은 기술이 등장한다.URL(Uniform Resource Locator)란? 인터넷 상의 리소스의 위치 특정 웹 서버의 특정 파일에 접근하기 위한 경로 혹은 주소동작 방식 요청 메서드 : GET, PUT, POST, PUSH, OPTIONS 등의 요청 방식(요청 종류)이 온다. 요청 URI : 요청하는 자원의 위치를 명시한다. HTTP 프로토콜 버전 : 웹 브라우저가 사용하는 프로토콜 버전이다.2. 웹 프론트엔드와 백엔드웹 프론트엔드사용자에게 웹을 통해 다양한 콘텐츠(리소스)를 제공한다. 또한, 사용자의 요청(요구 사항)에 반응하여 동작한다. 웹 콘텐츠, 즉 리소스를 잘 보여주기 위한 구조를 만들어야한다. (HTML) 적절한 배치와 일관된 디자인을 제공해야 한다. (CSS) 사용자 요청을 소통하듯이 잘 반영해야 한다. (Javascript)웹 백엔드backend는 정보를 처리하고 저장하며, 요청에 따라 정보를 내려주는 역할을 한다. 가령 쇼핑몰이라면, 상품 정보를 가지고 있고, 주문을 받아서 저장하고, 사용자가 관심있어 하는 상품을 골라주는 역할이 back-End의 역할이다.References 및 이미지 출처 https://www.boostcourse.org/web326/lecture/58930?isDesc=false https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=https%3A%2F%2Ft1.daumcdn.net%2Fcfile%2Ftistory%2F9946B03E5C80849217" }, { "title": "웹 백엔드 1-2 Maven 및 기초 환경 세팅", "url": "/posts/backend-2/", "categories": "Back-end", "tags": "web, backend, tutorial", "date": "2022-07-25 01:13:00 +0900", "snippet": "본 글은 네이버 부스트 코스: 웹 백엔드 코스를 공부하며 정리한 글입니다.다만 해당 코스가 순수 백엔드 공부용으로 제작된 것이 아니라 풀스택 강의의 일부를 재사용했기 때문에 강의 순서가 맞지 않는 경우에는 부스트 코스 순서와 일치하지 않을 수 있습니다.1. Maven프로젝트가 복잡해질수록 라이브러리 관리 및 소스 코드 컴파일과 배포가 어려워지게 된다. 이를 해결하기 위한 방법 중 하나가 Maven이다. Maven을 이용하면 빌드, 패키징, 문서화, 테스트와 테스트 리포팅, git, 의존성 관리, svn 등과 같은 형상 관리 서버와의 연동(SCMs), 배포 등의 작업을 손쉽게 할 수 있다.CoCCoC는 Convention over Configuration의 약자로, 일종의 관습을 말하는데, 이를테면 프로그램의 소스 파일은 어떤 위치에 있어야 하고 컴파일된 파일은 또 어떤 위치에 있어야 하고 등을 미리 정해둔 것이다. Maven을 사용하는 것은 넓게 보면 이러한 CoC에 관해서 알아가는 것이라고도 할 수 있다.Maven 기본Maven 기반 프로젝트를 생성할 경우 프로젝트 하위에 생성되는 pom.xml 파일을 살펴보자.&amp;lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd&quot;&amp;gt; &amp;lt;modelVersion&amp;gt;4.0.0&amp;lt;/modelVersion&amp;gt; &amp;lt;groupId&amp;gt;kr.or.connect&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;examples&amp;lt;/artifactId&amp;gt; &amp;lt;packaging&amp;gt;jar&amp;lt;/packaging&amp;gt; &amp;lt;version&amp;gt;1.0-SNAPSHOT&amp;lt;/version&amp;gt; &amp;lt;name&amp;gt;mysample&amp;lt;/name&amp;gt; &amp;lt;url&amp;gt;http://maven.apache.org&amp;lt;/url&amp;gt; &amp;lt;dependencies&amp;gt; &amp;lt;dependency&amp;gt; &amp;lt;groupId&amp;gt;junit&amp;lt;/groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;/artifactId&amp;gt; &amp;lt;version&amp;gt;3.8.1&amp;lt;/version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;/scope&amp;gt; &amp;lt;/dependency&amp;gt; &amp;lt;/dependencies&amp;gt;&amp;lt;/project&amp;gt;사용된 용어 project: pom.xml 파일의 최상위 root element modelVersion: POM model의 버전 groupId: 프로젝트를 생성하는 조직의 고유 아이디 artifactId: 해당 프로젝트에 의해 생성되는 artifact의 고유 아이디 artifactid-version.packaging과 같이 생성됨 packaging: 프로젝트를 어떤 형태로 패키징할 것인지 결정 version: 프로젝트의 현재 버전 name: 프로젝트명 url: 프로젝트 사이트 URL(일반적) 이때 Dependency Management가 가능하다는 것에 주목하자. &amp;lt;dependencies/&amp;gt; 엘리먼트 안에 필요한 라이브러리를 저장하게 된다.2. Maven을 이용한 웹 어플리케이션 실습네이버 부스트코스에서는 Eclipse를 사용하지만, 나는 IntelliJ를 주로 사용하기 때문에 다른 개인 블로그 글을 참조해서 해당 실습을 수행해보았다.일부 순서가 맞지 않아 부스트 코스 2강 수강 후 추가적인 환경 세팅을 할 예정이다. Tomcat은 공식 사이트에서 미리 다운로드 받아놓았다. 해당 블로그 링크에서 추가적으로 servlet을 추가해줄 것이다. Dependency를 추가하고 나면 옆의 새로고침 표시를 클릭하거나 pom.xml &amp;gt; 오른쪽 마우스 &amp;gt; maven &amp;gt; Reload project로 새로고침 해주자. JSTL도 추가해보자. (부스트 코스 2강 먼저 수강 후 추가 예정) References https://www.boostcourse.org/web326/lecture/58930?isDesc=false" }, { "title": "웹 백엔드 1-1 데이터베이스", "url": "/posts/backend-1/", "categories": "Back-end", "tags": "web, backend, tutorial", "date": "2022-07-25 00:55:00 +0900", "snippet": "본 글은 네이버 부스트 코스: 웹 백엔드 코스를 공부하며 정리한 글입니다.1. 데이터베이스데이터베이스란 데이터의 집합(a set of data)을 말한다. 여러 응용 시스템들의 통합된 정보를 저장하여 운영할 수 있는 공용 데이터의 집합 효율적인 저장, 검색, 업데이트를 위해 데이터 집합 간의 연관을 조직화해야한다.데이터베이스의 특성 Real-time Accessability: 사용자의 요구를 즉시 처리한다. Continous Evolution: 정확한 값을 유지하기 위해 삽입, 삭제, 수정 작업 등의 작업으로 데이터를 지속적으로 갱신한다. Concurrent Sharing: 여러 사용자가 동일한 데이터에 접근하고 이용할 수 있다. Content Reference: 저장한 데이터를 데이터의 주소가 아닌 사용자가 요구하는 데이터 값에 따라 참조할 수 있어야 한다.Database Management System데이터베이스를 관리하는 소프트웨어로, 여러 응용 소프트웨어 또는 시스템이 동시에 데이터베이스에 접근하여 사용할 수 있게 한다. 정의 기능: 데이터 베이스의 논리적, 물리적 구조를 정의 조작 기능: 데이터를 검색, 삽입, 삭제, 수정하는 기능 제어 기능: 데이터베이스 내용의 정확성과 안정성을 유지하는 기능2. SQLSQL은 Structed Query Language의 약자로, 데이터를 보다 쉽게 검색하고 조작할 수 있게 고안된 컴퓨터 언어이다. 관계형 데이터베이스에서 데이터를 조작하고 쿼리하는 표준 수단이기도 하다. Data Manipulation Language: 데이터를 조작한다. INSERT, UPDATE, DELETE, SELECT Data Definition Language: 데이터베이스의 스키마를 정의하거나 조작한다. CREATE, DROP, ALTER Data Control Language: 권한을 관리하거나 데이터의 보안, 무결성 등을 정의하여 데이터를 제어한다. GRANT, REVOKE References https://www.boostcourse.org/web326/lecture/58930?isDesc=false" }, { "title": "Pytorch tutorials 07 | 모델 저장하고 불러오기", "url": "/posts/pytorch-tutorial-7/", "categories": "ML, pytorch", "tags": "ML, pytorch, tutorial", "date": "2022-05-30 13:50:00 +0900", "snippet": "마지막으로 모델의 예측을 저장, 로드 및 실행하여 모델의 state를 유지하는 방법에 관해 알아보려고 한다.import torchimport torchvision.models as modelsSaving and Loading Model WeightsPytorch의 모델은 학습한 매개변수를 state_dict라고 불리는 internal state dictionary에 저장한다. 이 상태 값들은 torch.save를 사용하여 저장(persist)할 수 있다.model = models.vgg16(pretrained = True)torch.save(model.state_dict(), &#39;model_weights.pth&#39;)모델 weights를 불러오기 위해서는, 먼저 동일한 모델의 인스턴스(instance)를 생성한 다음에 load_state_dict() 메소드를 사용하여 매개변수들을 불러온다.model = models.vgg16()model.load_state_dict(torch.load(&#39;model_weights.pth&#39;))model.eval() Inference를 하기 전에, model.eval() 메소드를 호출하여 dropout과 batch normalization을 evaluation mode로 설정해야 한다.Saving and Loading Models with Shapes모델의 weights를 불러올 때, 신경망의 구조를 정의하기 위해 모델 클래스를 먼저 생성해야 한다. 이 클래스의 구조를 모델과 함께 저장하려면 model (not model.state_dict())을 저장 함수에 전달해야 한다.torch.save(model, &#39;model.pth&#39;)그러면 다음과 같이 모델을 불러올 수 있다.model = torch.load(&#39;model.pth&#39;) 이러한 접근 방식은 Python pickle 모듈을 사용하여 모델을 직렬화한다.References https://tutorials.pytorch.kr/beginner/basics/saveloadrun_tutorial.html" }, { "title": "Pytorch tutorials 06 | 모델 매개변수 최적화하기", "url": "/posts/pytorch-tutorial-6/", "categories": "ML, pytorch", "tags": "ML, pytorch, tutorial", "date": "2022-05-18 16:00:00 +0900", "snippet": "이때까지의 과정을 통해 모델과 데이터를 준비했다. 이제는 데이터에 매개변수를 최적화하여 모델을 학습하고, 검증(평가)하고, 테스트할 차례이다.모델을 학습하는 과정은 다음과 같은 반복적인 과정(epoch)을 거친다. 모델은 출력을 추측한다. 추측과 실제 정답 사이의 오류(loss)를 계산한다. 매개변수에 대한 오류의 도함수를 수집하고, Gradient descent를 사용하여 이러한 매개변수를 최적화(optimize)한다.이론과 관련하여 자세한 사항은 따로 Back propagation을 정리해놓은 영상을 참조해보자.Pre-requisite code이전 장을 거치며 작성된 코드이다.import torchfrom torch import nnfrom torch.utils.data import DataLoaderfrom torchvision import datasetsfrom torchvision.transforms import ToTensor, Lambdatraining_data = datasets.FashionMNIST( root=&quot;data&quot;, train=True, download=True, transform=ToTensor())test_data = datasets.FashionMNIST( root=&quot;data&quot;, train=False, download=True, transform=ToTensor())train_dataloader = DataLoader(training_data, batch_size=64)test_dataloader = DataLoader(test_data, batch_size=64)class NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logitsmodel = NeuralNetwork()HyperparameterHyperparameter는 모델 최적화 과정을 제어할 수 있는 조절 가능한 매개변수이다. 이는 모델 학습과 수렴율(convergence rate)에 영향을 미친다.학습할 때에는 다음과 같은 하이퍼파라미터를 정의한다. Epoch 수: 데이터셋을 반복하는 횟수 batch size: 매개 변수가 갱신되기 전 신경망을 통해 전파된 데이터 샘플의 개수 learning rate: 각 batch / epoch에서 모델의 매개변수를 조절하는 비율learning_rate = 1e-3batch_size = 64epochs = 5Optimization LoopOptimization 단계의 각 iteration을 Epoch이라고 부르는데, 하나의 Epoch은 두 가지로 loop로 구성된다. Train loop: 학습용 데이터 셋을 반복하고 최적의 매개변수로 수렴 Validation / test loop: 모델 성능이 개선되고 있는지 확인하기 위해 테스트 데이터 셋을 반복Loss functionLoss function, 손실 함수는 획득(계산)한 결과와 실제 값 사이의 틀린 정도(degree of dissimilarity)를 측정하며, training 중에 이 값을 최소화하려고 한다.loss_fn = nn.CrossEntropy()Optimizer각 train loop에서 모델의 error을 줄이기 위해 모델 매개변수를 조정한다. 최적화 알고리즘은 이 과정이 수행되는 방식을 정의한다. (여기에서는 Stochastic Gradient Descent를 사용함)optimizer = torch.optim.SGD(model.parameters(), lr = learning_rate)Train loop에서 optimization은 다음과 같은 세 단계로 이루어진다: optimizer.zero_grad()를 호출하여 모델 매개변수의 gradient를 재설정 한다. (default: add up) 중복 카운팅을 방지하기 위해, 각 순회 회차마다 0으로 명시적으로 설정한다. loss.backward()를 호출하여 예측 loss를 back propagation한다. Pytorch에서는 각 매개변수에 대한 loss의 gradient를 저장한다. gradient를 계산한 뒤에는 optimizer.step()을 호출하여 back propagation 단계에서 수집된 gradient로 매개변수를 조정한다.Full implementationdef train_loop(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) for batch, (X, y) in enumerate(dataloader): # Compute prediction and loss pred = model(X) loss = loss_fn(pred, y) # Backpropagation optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f&quot;loss: {loss:&amp;gt;7f} [{current:&amp;gt;5d}/{size:&amp;gt;5d}]&quot;)def test_loop(dataloader, model, loss_fn): size = len(dataloader.dataset) num_batches = len(dataloader) test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= num_batches correct /= size print(f&quot;Test Error: \\n Accuracy: {(100*correct):&amp;gt;0.1f}%, Avg loss: {test_loss:&amp;gt;8f} \\n&quot;)loss_fn = nn.CrossEntropyLoss()optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)epochs = 10for t in range(epochs): print(f&quot;Epoch {t+1}\\n-------------------------------&quot;) train_loop(train_dataloader, model, loss_fn, optimizer) test_loop(test_dataloader, model, loss_fn)print(&quot;Done!&quot;)References https://tutorials.pytorch.kr/beginner/basics/optimization_tutorial.html" }, { "title": "Pytorch tutorials 05 | TORCH.AUTOGRAD를 사용한 자동 미분", "url": "/posts/pytorch-tutorial-5/", "categories": "ML, pytorch", "tags": "ML, pytorch, tutorial", "date": "2022-05-14 00:11:00 +0900", "snippet": "신경망을 학습할 때 가장 자주 사용되는 알고리즘인 Back Propagation에서, 매개변수(weight과 bias)는 주어진 매개변수에 대한 Error function의 Gradient에 따라 조정된다.이를 위해 Pytorch에 내장되어 있는 자동 미분 엔진 torch.autograd를 사용한다.Input x, Weight w, Bias b, 그리고 Error function이 있는 간단한 Single Layer Neural Network를 Pytorch에서 정의해보자.import torchx = torch.ones(5) # input tensory = torch.zeros(3) # expected outputw = torch.randn(5, 3, requires_grad = True)b = torch.randn(3, requries_grad = True)z = torch.matmul(x, w) + bloss = torch.nn.functional.binary_cross_entropy_with_logits(z, y)위의 코드는 다음의 Computational graph를 정의한다.이때, w와 b가 최적화를 해야하는 매개변수이다.Gradient 계산하기Neural network에서 매개변수의 가중치를 최소화하기 위해서는 매개벼수에 대한 Error function의 도함수(derivative)를 계산해야 한다.즉, 다시 말해 어떤 각각의 고정값 x와 y에 대해 $\\frac{\\partial loss}{\\partial w}$와 $\\frac{\\partial loss}{\\partial b}$를 계산해야 한다.이러한 도함수 계산을 위해, loss.backward()를 호출한 뒤, w.grad와 b.grad에서 값을 가져온다.loss.backward()print(w.grad)print(b.grad)Gradient 추적 멈추기기본적으로 requires_grad = True로 설정된 모든 텐서는 연산 기록이 추적되며 Gradient 계산도 지원된다. 그러나 Forward propagation 연산만 필요한 경우, 이러한 추적이나 계산이 필요 없을 수도 있기 때문에 연산 코드를 torch.no_grad()로 둘러싸서 추적을 멈출 수 있다.with torch.no_grad() z = torch.matmul(x, w) + bprint(z.requires_grad) Gradient 추적을 왜 멈춰야 할까? - Neural network의 일부 매개변수를 frozen parameter로 표시한다. - Forward propagation 단계만 수행할 때 연산 속도가 향상된다.Computational Graph에 대한 추가 정보autograd는 데이터(tensor)와 실행된 모든 연산의 기록을 Function 객체로 구성된 Directed Acyclic Graph에 저장한다. 이 그래프의 leaf들은 input tensor이고, root는 output tensor이다. 그래프를 root부터 leaf까지 추적하면 chain rule에 따라 gradient를 자동으로 계산할 수 있다. Forward propagation 단계에서, autograd의 작업: 요청된 연산을 수행하여 결과 텐서를 계산 DAG에 연산의 Gradient function을 유지 Back propagation 단계는 DAG의 root에서 .backward()가 호출될 때 시작되며, 이 때 autograd의 작업: 각 .grad_fn으로부터 gradient를 계산 각 텐서의 .grad 속성에 계산 결과를 축적 chain rule을 사용하여, 모든 leaf 텐서들까지 전파 Image Source https://tutorials.pytorch.kr/_images/comp-graph.pngReferences https://tutorials.pytorch.kr/beginner/basics/autogradqs_tutorial.html" }, { "title": "Pytorch tutorials 04 | 신경망 모델 구성하기", "url": "/posts/pytorch-tutorial-4/", "categories": "ML, pytorch", "tags": "ML, pytorch, tutorial", "date": "2022-05-12 09:40:00 +0900", "snippet": "신경망은 데이터 연산을 수행하는 layer / module로 구성되어있다.torch.nn 네임스페이스는 신경망을 구성하는데 필요한 모든 구성 요소를 제공한다.FashionMNIST 데이터셋의 이미지를 분류하는 신경망을 구성해보자.import osimport torchfrom torch import nnfrom torch.utils.data import DataLoaderfrom torchvision import datasets, transforms학습을 위한 장치 얻기가능한 경우 GPU와 같은 하드웨어 가속기에서 모델을 학습하자.device = &quot;cuda&quot; is torch.cuda.is_available() else &quot;cpu&quot;print(f&quot;Using {device} device&quot;)클래스 정의하기신경망 모델을 nn.Module의 하위클래스로 정의하고, __init__에서 신경망 계층을 초기화한다. nn.Module을 상송받은 모든 클래스는 forward 메소드에 입력 데이터에 대한 연산들을 구현한다.class NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logitsNeuralNetwork의 instance를 생성하고 이를 device로 이동한 뒤, structure을 출력한다.model = NeuralNetwork().to(device)print(model)모델을 사용하기 위해 입력 데이터를 전달한다. 이는 일부 백그라운드 연산과 함께 모델의 forward를 실행한다. model.forward()를 직접 호출하지 말자.모델에 입력을 호출하면 각 class에 대한 raw 예측 값이 있는 10차원 텐서가 반환된다. raw 예측 값을 nn.Softmax 모듈의 인스턴스에 통과시켜 예측 확률을 얻을 수 있다.X = torch.rand(1, 28, 28, device = device)logits = model(X)pred_probab = nn.Softmax(dim = 1)(logits)y_pred = pred_probab.argmax(1)print(f&quot;Predicted class: {y_pred}&quot;)LayerFashionMNIST 모델의 layer을 28*28 크기의 이미지 3개로 구성된 미니배치 예제를 통해 살펴보자.input_image = torch.rand(3, 28, 28)nn.Flattennn.Flatten layer를 초기화하여 각 28*28의 2D 이미지를 784 픽셀을 갖는 연속된 배열로 반환한다.flatten = nn.Flatten()flat_image = flatten(input_image)nn.Linear선형 계층은 저장된 weight과 bias를 사용하여 입력에 linear transformation을 적용하는 모듈이다.layer1 = nn.Linear(in_features = 28*28, out_features = 20)hidden1 = layer1(flat_image)nn.ReLUnon-linear activation은 모델의 입력과 출력 사이에 복잡한 mapping을 만든다. non-linear activation은 선형 변환 후 적용되어 nonlinearity를 도입하며, 신경망이 다양한 현상을 학습할 수 있도록 돕는다.hidden1 = nn.ReLU()(hidden1)nn.Sequentialnn.Sequential은 순서를 갖는 모듈의 컨테이너로, 데이터는 정의된 순서로 모든 모듈들을 통해 전달된다. sequential container를 사용하여 일부 신경망을 빠르게 만들 수 있다.seq_modules = nn.Sequential( flatten, layer1, nn.ReLU(), nn.Linear(20, 10))input_image = torch.rand(3,28,28)logits = seq_modules(input_image)nn.Softmax신경망의 마지막 선형 계층은 nn.Softmax 모듈에 전달될 ([-infty, infty] 범위의 raw value인) logits 를 반환한다. 이때, logits는 모델의 각 class에 대한 예측 확률을 나타내도록 [0, 1] 범위로 조정된다.softmax = nn.Softmax(dim = 1)pred_probab = softmax(logits)모델 매개변수신경망 내부의 많은 계층은 parameterize된다. 즉, 학습 중에 최적화되는 weight, bias와 연관지어진다. nn.Module를 상속하면 모델 객체 내부의 모든 필드를 자동으로 추적할 수 있게 되며, 모델의 parameters() 및 named_parameters() 메소드로 모든 매개변수에 접근할 수 있다.References https://tutorials.pytorch.kr/beginner/basics/buildmodel_tutorial.html" }, { "title": "Pytorch tutorials 03 | Transform", "url": "/posts/pytorch-tutorial-3/", "categories": "ML, pytorch", "tags": "ML, pytorch, tutorial", "date": "2022-05-11 12:40:00 +0900", "snippet": "때때로 머신러닝 알고리즙 학습을 위해서는 데이터를 변형(transform)해서 데이터를 조작하고 학습에 적합하게 만들어야 한다.모든 TorchVision 데이터셋들은 변형 로직을 가진, 호출 가능한 객체(callable)를 받는 매개 변수 두개 특징(feature)을 변경하기 위한 transform 정답(label)을 변경하기 위한 target_transform을 갖는다.FashionMNINST의 feature는 PIL Image 형식이고, label은 Interger이다. 학습을 하기 위해서는 Normarlize된 텐서 형태의 feature과 one-hot으로 encode된 텐서 형태의 label이 필요하다. 따라서, 이러한 transformation을 하기 위해 ToTensor와 Lambda를 사용한다.import torchfrom torchvision import datasetsfrom torchvision.transforms import ToTensor, Lambdads = datasets.FashionMNIST( root = &quot;data&quot;, train = True, download = True, transform = ToTensor(), target_transform = Lambda(lambda y: torch.zeros(10, dtype = torch.float).scatter_(0, torch.tensor(y), value = 1)))ToTensor()ToTensor는 PIL Image나 NumPy ndarray를 FloatTensor로 변환하고, 이미지의 픽셀의 크기(intensity) 값을 [0., 1.] 범위로 비례하여 조정한다.Lambda 변형(Transform)Lambda 변형은 사용자 정의 람다(lambda) 함수를 적용한다.References https://tutorials.pytorch.kr/beginner/basics/transforms_tutorial.html" }, { "title": "백준 11729", "url": "/posts/baekjoon11729/", "categories": "Computer, PS", "tags": "baekjoon, ps", "date": "2022-05-11 00:43:00 +0900", "snippet": "저번 2447번과 마찬가지로 자바로 풀었을 땐 자꾸 시간 초과가 떴는데, C++로 풀자 시간 초과가 되지 않았다…처음에는 하노이탑을 전부 구현해보고 싶어서 hanoiTower[3][N]의 int 배열을 선언하고 전부 -1로 초기화한 뒤, 각 블럭에 넘버링 해주고 옮길 때마다 배열 요소를 바꾸는 그런걸 생각했었는데, 시간이 초과되기도 하고 더 간단하게 구현하는게 편할 것 같아서 다시 처음부터 작성했다.옮기는 횟수도 재귀함수로 구했었는데 시간초과되길래 점화식으로부터 직접 계산 식을 구하고 구한 식을 바로 코드에 넣어줬다.만약 옮기는 횟수도 재귀함수로 구현했다면,int moveHanoiTowerCount(int N){ if(N == 1) return 1; return 2 * moveHanoiTowerCount(N - 1) + 1;}이렇게 계산하면 됐었던 것 같다.그러나 전체적으로 고쳤기 때문에 최종적으로는#include&amp;lt;stdio.h&amp;gt;#include&amp;lt;math.h&amp;gt;void showHanoi(int N, int start, int end, int mid){ if(N == 1){ printf(&quot;%d %d\\n&quot;, start, end); return; } showHanoi(N - 1, start, mid, end); printf(&quot;%d %d\\n&quot;, start, end); showHanoi(N - 1, mid, end, start);}int main(){ int N; scanf(&quot;%d&quot;, &amp;amp;N); int result = (int)pow(2, N) - 1; printf(&quot;%d\\n&quot;, result); showHanoi(N, 1, 3, 2);}와 같이 돌아가는 코드를 작성할 수 있었다." }, { "title": "Pytorch tutorials 02 | Dataset과 DataLoader", "url": "/posts/pytorch-tutorial-2/", "categories": "ML, pytorch", "tags": "ML, pytorch, tutorial", "date": "2022-05-10 13:55:00 +0900", "snippet": "데이터셋 코드는 더 나은 가독성과 모듈성을 위해 모델 학습 코드로부터 분리하는 것이 좋다.Pytorch에서는 torch.utils.data.DataLoader와 torch.utils.data.Dataset의 두 가지 데이터 기본 요소를 통해 미리 준비된(pre-loaded) 데이터 셋은 물론 가지고 있는 데이터를 사용할 수도 있다.Dataset은 샘플과 정답(label)을 저장하고, DataLoader는 Dataset을 샘플에 쉽게 접근할 수 있도록 순회 가능한 객체(iterable)로 감싼다.데이터셋 불러오기TorchVision에서 [FashionMNIST] 데이터셋을 불러오는 예제를 살펴보자. root: 학습/테스트 데이터가 저장되는 경로 train: 학습용 또는 테스트 데이터셋 여부를 지정 download=True: root에 데이터가 없는 경우 인터넷에서 다운로드 transform과 target_transform: feature과 label transform을 지정import torchfrom torch.utils.data import Datasetfrom torchvision import datasetsfrom torchvision.transforms import ToTensorimport matplotlib.pyplot as plttraining_data = datasets.FashionMNIST( root = &quot;data&quot;, train = True, download = True, transform = ToTensor())test_data = datasets.FashionMNIST( root = &quot;data&quot;, train = False, download = True, transform = ToTensor())데이터 셋을 순회하고 시각화하기Dataset에 List처럼 직접 접근(index)할 수 있다. 예: training_data[index]labels_map = { 0: &quot;T-Shirt&quot;, 1: &quot;Trouser&quot;, 2: &quot;Pullover&quot;, 3: &quot;Dress&quot;, 4: &quot;Coat&quot;, 5: &quot;Sandal&quot;, 6: &quot;Shirt&quot;, 7: &quot;Sneaker&quot;, 8: &quot;Bag&quot;, 9: &quot;Ankle Boot&quot;,}figure = plt.figure(figsize=(8,8))cols, rows = 3, 3for i in range(1, cols * rows + 1): sample_idx = torch.randint(len(training_data), size=(1,)).item() img, label = training_data[sample_idx] figure.add_subplot(rows, cols, i) plt.title(labels_map[label]) plt.axis(&quot;off&quot;) plt.imshow(img.squeeze(), cmap = &quot;gray&quot;)plt.show()파일에서 사용자 정의 데이터셋 만들기사용자 정의 Dataset 클래스는 반드시 3개의 함수를 구현해야 한다. __init__ Dataset 객체가 생성(instantiate)될 때 한 번만 실행된다. __len__ 데이터셋의 샘플 개수를 반환한다. __getitem__ 주어진 인덱스 idx에 해당하는 샘플을 데이터셋에서 불러오고 반환한다. 인덱스를 기반으로, 디스크에서 이미지의 위치를 식별하고, read_image를 사용하여 이미지를 텐서로 변환하고, self.img_labels의 csv 데이터로부터 해당하는 정답(label)을 가져오고, 해당되는 경우 변형(transform) 함수들을 호출한 뒤, 텐서 이미지와 라벨을 Python 사전(dict)형으로 반환한다. import osimport pandas as pdfrom torchvision.io import read_imageclass CustomImageDataset(Dataset): def __init__(self, annotations_file, img_dir, transform=None, target_transform=None): self.img_labels = pd.read_csv(annotations_file, names = [&#39;file_name&#39;, &#39;label&#39;]) self.img_dir = img_dir self.transform = transform self.target_transform = target_transform def __len__(self): return len(self.img_labels) def __getitem__(self, idx): img_path = os.path.join(self.img_dir, self.img_labels.iloc[idx, 0]) image = read_image(image_path) label = self.img_labels.iloc[idx, 1] if self.transform: image = self.transform(image) if self.target_transform: label = self.target_transform(label) return image, labelDataLoader로 학습용 데이터 준비하기Dataset은 데이터셋의 feature을 가져오고, 하나의 샘플에 label을 지정하는 일을 한 번에 수행한다.모델을 학습할 때, 일반적으로 샘플들을 minibatch로 전달하고, 매 epoch마다 데이터를 다시 섞어서 overfit을 막는다. 또한, Python의 multiprocessing을 사용하여 데이터 검색 속도를 높인다.DataLoader는 간단한 API로, 이러한 복잡한 과정을 추상화한 순회 가능한 객체(iterable)이다.from torch.utils.data import DataLoadertrain_dataloader = DataLoader(training_data, batch_size = 64, shuffle = True)test_dataloader = DataLoader(test_data, batch_size = 64, shuffle = True)DataLoader를 통해 순회하기(iterate)DataLoader에 데이터 셋을 불러오고 나서는, 필요에 따라 데이터 셋을 순회(iterate)할 수 있다.# 이미지와 정답(label)을 표시한다.train_features, train_label = next(iter(train_dataloader))print(f&quot;Feature batch shape: {train_features.size()}&quot;)print(f&quot;Labels batch shape: {train_labels.size()}&quot;)img = train_features[0].squeeze()label = train_labels[0]plt.imshow(img, cmap = &quot;gray&quot;)plt.show()print(f&quot;Label: {label}&quot;)References https://tutorials.pytorch.kr/beginner/basics/data_tutorial.html https://wikidocs.net/32829 https://gooopy.tistory.com/68" }, { "title": "Pytorch tutorials 01 | Tensor", "url": "/posts/pytorch-tutorial-1/", "categories": "ML, pytorch", "tags": "ML, pytorch, tutorial", "date": "2022-05-10 12:50:00 +0900", "snippet": "모든 코드는 colab에서 실행했다.텐서(tensor)란, 배열(array)이나 행렬(matrix)와 비슷한 특수한 자료 구조이다. Pytorch에서는 텐서를 사용하여 모델의 input과 output, 그리고 매개 변수 등을 encode한다.import torchimport numpy as np텐서 초기화텐서는 여러가지 방법으로 초기화할 수 있다.1. 데이터로부터 직접(directly) 생성데이터로부터 직접 텐서를 생성할 수 있으며, 자료형은 자동으로 유추된다.data = [[1,2],[3,4]]x_data = torch.tensor(data)2. 다른 텐서로부터 생성명시적으로 override하지 않는 경우, 인자로 주어진 텐서의 속성(shape, datatype)을 유지한다. 텐서의 속성에 관해서는 아래에서 자세히 살펴볼 수 있다.x_ones = torch.ones_like(x_data) # x_data의 텐서 속성을 유지x_rand = torch.rand_like(x_Data, dtype = torch.float) # x_data의 텐서 속성을 재정의3. Random한 값 혹은 Constant 값을 사용shape은 텐서의 dimension을 나타내는 tuple로, 출력 텐서의 차원을 결정한다.shape = (2,3,)rand_tensor = torch.rand(shape) # random한 value를 요소로 갖는 텐서 생성ones_tensor = torch.ones(shape) # 상수 &#39;1&#39;을 요소로 갖는 텐서 생성zeros_tensor = torch.zeros(shape) # 상수 &#39;0&#39;을 요소로 갖는 텐서 생성텐서의 속성(Attribute)텐서의 속성은 다음 두 가지로 구성된다. 모양: tensor.shape 자료형: tensor.datatype 어느 장치에 저장되어 있는지: tensor.device텐서 연산(Operation)Transposing, Indexing, Slicing, 그 외 여러 수학 계산, 선형 대수, Random sampling 등 다양한 텐서 연산을 공식 docs에서 확인할 수 있다. GPU로 텐서 이동 기본적으로 텐서는 CPU에 생성되지만, 명시적으로 GPU에 이동시킬 수 있다. # GPU가 존재하는 경우, 텐서를 이동한다 if torch.cuda.is_available(): tensor = tensor.to(&quot;cuda&quot;) NumPy식의 표준 Indexing과 Slicing tensor = torch.rand(4,4) print(f&quot;First row: {tensor[0]}&quot;) print(f&quot;First Column: {tensor[:,0]}&quot;) print(f&quot;Last Column: {tensor[...,-1]}&quot;) tensor[:,1] = 0 print(tensor) 텐서 합치기 주어진 차원에 따라 일련의 텐서를 연결할 수 있다. t1 = torch.cat([tensor, tensor, tensor], dim = 1) 산술 연산(Arithmetic operations) # 두 텐서 간의 matrix multiplication을 계산하는 3가지 방법 y1 = tensor @ tensor.T y2 = tensor.matmul(tensor.T) y3 = torch.rand_like(tensor) torch.matmul(tensor, tensor.T, out = y3) # 두 텐서 간의 element-wise product를 계산하는 3가지 방법 z1 = tensor * tensor z2 = tensor.mul(tensor) z3 = torch.rand_like(tensor) torch.mul(tensor, tensor, out = z3) Single-element 텐서 텐서의 모든 값을 하나로 aggregate하여 요소가 하나인 텐서의 경우, 이를 Python 숫자 값으로 변경할 수 있다. agg = tensor.sum() agg_item = agg.item() In-place 연산 연산 결과를 피연산자(operand)에 저장하는 연산을 In-place 연산이라고 부르며, 해당 연산은 메서드에 _ 접미사를 갖는다. tensor.add_(5) In-place 연산은 도함수(derivative) 계산에 문제를 일으킬 수도 있으므로 사용을 권장하지 않는다. NumPy 변환(Bridge)CPU 상의 텐서와 NumPy 배열은 메모리 공간을 공유하므로, 하나를 변경하면 다른 하나도 변경된다.References https://tutorials.pytorch.kr/beginner/basics/tensorqs_tutorial.html" }, { "title": "Android 기초 2.1 Activities and intents", "url": "/posts/android-basic-4/", "categories": "Android, Fundamentals", "tags": "android, codelab", "date": "2022-05-01 15:15:00 +0900", "snippet": " 지난 글: 1.3 Text and scrolling viewsActivityActivity란, 앱 이용자가 하나의 집중된 행위를 할 수 있는 단일 화면을 나타낸다. (예: 메일 보내기, 사진 찍기, 지도 보기)앱은 주로 여러 개의 화면으로 이루어져 있는데, 각각은 느슨하게 연결되어있다. 각 화면은 모두 하나의 Activity다.우리가 프로그래밍할 때와 비슷하게, 앱이 launch될 때 가장 먼저 실행되는 Activity는 Main Activity다. 처음 한번 실행된 이후로도 물론 다시 불릴 수도 있다.새로운 Activity가 시작되면, 이전 Activity는 back stack으로 분류되며 정지된다. stack의 기본 원리인 LIFO에 따라, 현재 Activity에서 작업을 마치고 back button으로 돌아가면 stack에서 activity가 pop되면서 destory되고, 이전 activity가 다시 실행된다.IntentActivity는 intent와 함께 시작(활성화)된다. Intent란 Activity에서 다른 Activity 혹은 다른 앱 구성 요소로 어떤 액션 요청을 보낼 때 사용할 수 있는 비동기적 메시지이다. Intent를 사용하여 한 Activity에서 다른 Activity를 실행할 때, Activity 간에서 데이터를 넘길 수 있다. Explicit intent: intent의 target을 알고 있는 경우. Implicit intent: target 구성 요소의 이름을 알고 있진 않지만, 수행해야 할 일반적인 액션을 가지고 있는 경우. (나중에 다시 알아볼 예정)Codelabs Main Activity에서 특정 Text를 입력하고, Second Activity에 입력한 Text 데이터를 Intent로 넘겨준다. Second Activity에서는 Main Activity로부터 받은 Text를 표시하고, Main Activity로 돌아갈때 다시 Reply Text 데이터를 Intent로 넘겨준다.1. Create and launch another Activity: Intent 추가layout과 Java 파일을 가진 새로운 Activity를 프로젝트에 추가하면, AndroidManifest.xml에서 해당 Activity의 &amp;lt;activity&amp;gt; 요소를 확인할 수 있다. main activity와 마찬가지로 AppCompatActivity 클래스를 상속받는다.앱의 각 Activity는 다른 Activity들과 느슨하게 연결되어 있다. 하지만, AndroidManifest.xml 파일에서 하나의 Activity를 다른 Activity의 parent activity로 지정가능하다. 이러한 parent-child 관계를 통해 Android에서는 각 Activity의 제목 표시줄에 왼쪽 화살표와 같은 탐색 힌트를 추가할 수 있다.(1) Main Activity에 Button 추가하기Main Activity의 java 파일에 launchSecondActivity()를 정의한다.Main Activity의 레이아웃 xml 파일에 버튼을 추가한다. 버튼의 xml 코드를 수정하여 버튼 클릭 시 launchSecondActivity()가 실행되도록 설정해준다.&amp;lt;Button android:id=&quot;@+id/button_main&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:layout_marginBottom=&quot;16dp&quot; android:layout_marginRight=&quot;16dp&quot; android:text=&quot;@string/button_main&quot; android:onClick=&quot;launchSecondActivity&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; /&amp;gt;(2) Main Activity에 Intent 추가하기Main Activity에 명시적인 Intent를 추가하고, 새로운 Intent를 메서드 인자로 사용하는 startActivity()를 호출하기 위해 launchSecondActivity()에 다음과 같은 내용을 추가한다.Intent intent = new Intent(this, SecondActivity.class);startActivity(intent);2. 서로 다른 Activity 간에 데이터 주고받기: Intent로 데이터 넘기기서로 다른 Activity 간에 데이터를 주고받기 위해서는 (1)data field, (2)intent extras를 사용하는 2가지 방법이 있다. intent data는 작업할 특정 데이터를 나타내는 URI인데, intent를 통해 Activity에 전달하려는 정보가 URI가 아닌 경우, 혹은 전달하려는 정보가 두 개 이상인 경우, 추가 정보를 extras에 넣을 수 있다.(1) Main Activity에 EditText 추가하기Second Activity에 intent extras로 넘겨줄 문자열 값을 EditText를 통해 입력받는다.(2) Intent extras에 string 추가하기Intent extras는 Bundle의 key-value 쌍이다. 다른 Activity로 정보를 보내기 위해서는 Intent extra Bundle에 key-value들을 넣어줘야 한다. Intent extra의 key를 정의하기 위한 public 상수 추가public static final String EXTRA_MESSAGE = &quot;com.example.android.twoactivities.extra.MESSAGE&quot;; EditText를 연결헐 private 변수를 선언하고, 해당 변수를 onCreate()에서 findViewByID()로 찾아 연결한다. launchSecondActivity()의 Intent 선언 아래에 EditText의 text 데이터를 받아올 수 있도록 코드를 추가한다. 문자열을 Intent extra에 key-value 형태의 데이터로 추가한다.intent.putExtra(EXTRA_MESSAGE, message);MainActivity의 각 메서드는 다음과 같이 정리된다.@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mMessageEditText = findViewById(R.id.editText_main);}public void launchSecondActivity(View view) { Log.d(LOG_TAG, &quot;Button clicked!&quot;); Intent intent = new Intent(this, SecondActivity.class); String message = mMessageEditText.getText().toString(); intent.putExtra(EXTRA_MESSAGE, message); startActivity(intent);}(3) Second Activity에서 메시지를 받을 TextView 추가하기Main Activity에서 intent extra로 넘어온 문자열 데이터를 받아서 보여주기 위한 TextView를 추가해준다.(4) Get Extras and Display the message SecondActivity.java의 onCreate()에서 Activity를 활성화하는 Intent를 받아온다.Intent intent = getIntent(); MainActivity.EXTRA_MESSAGE static 변수를 key로 사용하여 Intent extras로부터 메시지를 포함하는 문자열을 받아온다.String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE); 레이아웃의 TextView를 findViewByID()를 사용하여 코드 내 변수와 연결한다. TextView의 텍스트를 Intent extra로부터 받은 문자열로 설정한다. textView.setText(message);SecondActivity의 메서드는 다음과 같이 정리된다.@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); Intent intent = getIntent(); String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE); TextView textView = findViewById(R.id.text_message); textView.setText(message);}3. Main Activity에 Reply를 건네주며 돌아오기Second Activity로부터 Main Activity로 데이터를 돌려주자(마찬가지로 intent extras를 이용한다.)(1) Second Activity Layout에 EditText와 Button을 추가하기이전 단계에서 했던 것처럼, Reply를 작성할 EditText와 전송을 Trigger할 Button을 SecondActivity의 Layout에 추가해준다.새로운 activity_second.xml은 다음과 같아질 것이다.(2) Second Activity에 Reponse Intent 추가하기이전에 했던 것과 마찬가지로 진행하면 된다.class의 상단에, Intent extra의 key를 정의하기 위한 public 변수를 설정한다.또한, EditText를 연결하기 위한 private 변수도 설정해준다.onCreate() 메서드에서는 findViewByID()로 EditText의 reference를 private 변수에 할당해준다.returnReply() 메서드에서는 EditText의 text를 설정하는 코드와, Reply를 위한 새로운 Intent를 생성하는 코드를 작성해준다. 이때, 이전에 사용했던 Intent를 사용하면 절대 안된다.EditText로부터 받은 reply 문자열을 새로운 intent의 Intent extra에 담아준다.replyIntent.putExtra(EXTRA_REPLY, reply);응답이 성공적이었다는 것을 나타내도록 결과를 RESULT_OK로 설정한다. Activity 클래스에서 result code를 정의하는데, RESULT_OK와 RESULT_CANCELLED로 나뉜다.setResult(RESULT_OK, replyIntent);현재 Activity를 닫고 MainActivity로 돌아가기 위해 finish()를 호출해준다.이전 단계를 포함하여, SecondActivity의 자바 코드는 다음과 같이 정리된다.public class SecondActivity extends AppCompatActivity { public static final String EXTRA_REPLY = &quot;com.example.android.twoactivities.extra.REPLY&quot;; private EditText mReply; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_second); mReply = findViewById(R.id.editText_second); Intent intent = getIntent(); String message = intent.getStringExtra(MainActivity.EXTRA_MESSAGE); TextView textView = findViewById(R.id.text_message); textView.setText(message); } public void returnReply(View view) { String reply = mReply.getText().toString(); Intent replyIntent = new Intent(); replyIntent.putExtra(EXTRA_REPLY, reply); setResult(RESULT_OK, replyIntent); finish(); }}(3) Main Activity에 Reply를 표시할 TextView 추가하기SecondActivity로부터 받은 reply를 MainActivity에 표시하기 위해, activity_main.xml에 TextView 구성 요소를 추가하자. 초기에는 보이지 않도록 설정하지 위해서는 android:visibility를 invisible로 설정해주면 된다.(4) Main Activity에서 Intent extra Reply 받고 표시하기다른 Activity를 시작하기 위해 명시적인 Intent를 사용했을 때, 만약 아무런 데이터도 넘기고 싶지 않다면 그냥 아예 이전 포스팅에서 해왔던 것처럼 startActivity()로 새로운 Activity를 시작해주면 된다. 그러나 이전에 활성화 되었던 Activity로부터 데이터를 받고 싶은 경우, startActivityForResult()로 해당 목표를 수행할 수 있다. MainActivity에서, 받고 싶은 특정 타입의 응답을 위한 key를 class 상단에 public 변수로 선언해준다.public static final int TEXT_REQUEST = 1; Reply header와 TextView를 연결하기 위한 두 개의 private 변수를 선언한다.private TextView mReplyHeadTextView;private TextView mReplyTextView;``` 앞서 2.에서 선언한 두 private 변수를 onCreate()메서드에서 findViewByID()로 실제 layout의 reply header와 reply TextView에 연결해준다.이제 MainActivity의 onCreate()는 이전 단계를 포함하여 다음과 같이 정리될 것이다.@Overrideprotected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mMessageEditText = findViewById(R.id.editText_main); mReplyHeadTextView = findViewById(R.id.text_header_reply); mReplyTextView = findViewById(R.id.text_message_reply);} 이제 launchSecondActivity()를 수정해주자. 기존의 startActivity()를 TEXT_REQUEST key를 포함하는 startActivityForResult()로 변경해주자.startActivityForResult(intent, TEXT_REQUEST); 콜백 메서드 onActivityResult()를 오버라이드한다.@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) {}세 개의 변수는 데이터를 리턴하는 동작을 수행하기 위한 모든 정보를 포함한다. * requestCode: startActivityForResult()로 Activity를 실행했을 때 설정 * resultCode: 실행된 Activity에서 설정됨(보통 RESULT_OK와 RESULT_CANCELLED로 나뉨) * Intent data: 실행된 Activity로부터 리턴된 데이터를 포함 onActivityResult()에 부모 생성자 super.onActivityResult()를 호출하자. Intent 결과가 제대로 왔는지 확인하기 위해 TEXT_REQUEST를 테스트하는 코드를 추가하자. if (requestCode == TEXT_REQUEST) { if (resultCode == RESULT_OK) { }} if 블럭 안에, Intent extra를 받는 코드를 추가해주자.String reply = data.getStringExtra(SecondActivity.EXTRA_REPLY); 그리고 이제 응답을 보여줄 reply header와 TextView 보이도록 설정해주자.mReplyHeadTextView.setVisibility(View.VISIBLE);mReplyTextView.setText(reply);mReplyTextView.setVisibility(View.VISIBLE);이제 전체 onActivityResult() 메서드는 다음과 같을 것이다.@Overridepublic void onActivityResult(int requestCode, int resultCode, Intent data) { super.onActivityResult(requestCode, resultCode, data); if (requestCode == TEXT_REQUEST) { if (resultCode == RESULT_OK) { String reply = data.getStringExtra(SecondActivity.EXTRA_REPLY); mReplyHeadTextView.setVisibility(View.VISIBLE); mReplyTextView.setText(reply); mReplyTextView.setVisibility(View.VISIBLE); } }}앱을 실행한후 Second Activity에서 응답을 보내면 다음과 같이 Main Activity에서 해당 응답을 받을 수 있다.Image Source https://developer.android.com/codelabs/android-training-create-an-activity/img/1ff9e83ac0bb3437.png?hl=ko https://developer.android.com/codelabs/android-training-create-an-activity/img/cd5302e2709828b7.png?hl=ko https://developer.android.com/codelabs/android-training-create-an-activity/img/d505e47d07ddd850.png?hl=ko https://developer.android.com/codelabs/android-training-create-an-activity/img/4acbc21712a8e6f7.png?hl=ko https://developer.android.com/codelabs/android-training-create-an-activity/img/e1c10fcdbf9a7e75.png?hl=koReferences https://developer.android.com/courses/fundamentals-training/toc-v2?hl=ko" }, { "title": "Android 기초 1.3 Text and scrolling views", "url": "/posts/android-basic-3/", "categories": "Android, Fundamentals", "tags": "android, codelab", "date": "2022-04-26 15:15:00 +0900", "snippet": " 지난 글: 1.2 대화형 UITextViewTextView 클래스는 View의 서브클래스로, 스크린에 텍스트를 표시한다.만약 디바이스 화면보다 더 많은 정보를 표시하려고 하는 경우, 사용자가 가로 혹은 세로로 스크롤해서 정보를 확인할 수 있게 하고 싶을 수도 있는데, 이 경우는 ScrollView를 활용할 수 있다.ScrollViewScrollView 클래스는 FrameLayout의 서브클래스로, 디바이스 화면에 표시가 안되고 있는 UI 구성 요소도 메모리 및 View 계층 구조에 있도록 할 수 있다. 텍스트가 이미 메모리 상에 있기 때문에 자유롭게 스크롤링할 수 있다. 그러나 메모리를 많이 사용하기 때문에 앱의 퍼포먼스에 끼치는 영향을 잘 고려해서 사용해야 한다.사용자가 추가, 삭제, 편집할 수 있는 많은 양의 아이템 리스트를 표시하기 위해서는 RecyclerView를 사용하는 것이 적절하다.References https://developer.android.com/courses/fundamentals-training/toc-v2?hl=ko" }, { "title": "Android 기초 1.2 대화형 UI", "url": "/posts/android-basic-2/", "categories": "Android, Fundamentals", "tags": "android, codelab", "date": "2022-04-15 15:00:00 +0900", "snippet": " 지난 글: 1.1 시작하기Layout Editor 살펴보기 activity_main.xml에서는 실제로 사용자에게 보이는 화면 구성을 확인할 수 있다. Design 탭을 사용하여 각종 Elements와 Layout을 조작할 수 있다. Code 탭에서는 Layout의 XML 코드를 편집할 수 있다. Palette 탭에서는 앱의 레이아웃에 사용할 수 있는 UI 구성 요소를 보여준다. Component tree에서는 UI 구성 요소의 계층 구조를 보여준다. 레이아웃 편집기의 Design 화면과 Blueprint 화면에서는 레이아웃의 UI 구성 요소를 보여준다. Attributes 탭에서는 UI 구성 요소의 Properties를 설정할 수 있다.Layout Editor에 View 구성 요소 추가하기 Constraint handle Resizing handleUI 구성 요소의 Attributes 변경Attributes 탭에서는 UI 구성 요소의 모든 XML Attributes에 접근할 수 있다. 자세한 내용은 이 곳에서 확인 가능하다.레이아웃 Width와 Height 설정layout_width와 layout_height Attributes는 View 창에서 보이는 넓이와 높이 크기를 변경할 수 있게 해준다. 이러한 Attributes로 ConstraintLayout의 다음 세 가지 값 중 하나를 선택할 수 있다. 이름 설명 표시 match_constraint Parent의 높이나 너비의 가능한 영역 전부를 채운다. wrap_content View 크기에 맞춘다. dp 디바이스의 스크린 사이즈에 맞는 고정된 사이즈를 지정한다. Hard-coding Strings 경고 문구와 관련하여 여기를 참조하여 해당 경고를 없앨 수 있다.Toast Message 출력Toast는 작은 팝업 창으로 간단한 메시지를 보여주는 기능을 제공한다. 메시지에 필요한 만큼의 공간만을 채운다. Toast는 일반적으로 다음과 같은 코드를 통해 그 인스턴스를 생성한다.Toast toast = Toast.makeText(this, R.string.toast_message, Toast.LENGTH_SHORT);ConstraintLayoutViewGroupLayout Variants 생성좀 더 쉽게 Horizontal(landscape)이나 Vertical(portrait) 방향에 대한 Layout Variants를 만드는 방법에 관해 알아보자.Horizontal 방향 레이아웃 미리보기 Android Studio 프로젝트를 열자. activity_main.xml 레이아웃 파일을 열고, Design 탭을 선택하자. Orientation in Editor 버튼 클릭 드롭다운 메뉴의 Switch to Landscape를 고르면 레이아웃이 Horizontal 방향으로 보여진다. 다시 세로로 돌리고 싶다면 Switch to Portrait을 골라주자.Horizontal 방향 Layout Variant 만들기 Orientation in Editor 버튼 을 클릭하자. Create Landscape Variation를 선택하자.그러면 이제 land/activity_main.xml 탭이 Horizontal 방향을 위한 레이아웃을 보여주며 새로운 에디터에서 열릴 것이다. 이제 본래의 Vertical 방향을 건드리지 않고 Horizontal 방향만을 수정할 수 있다. Project &amp;gt; Android 탭의 res &amp;gt; layout 디렉토리를 보면, 안드로이드 스튜디오가 자동으로 activity_main.xml (land)를 생성한 것을 볼 수 있다.Horizontal 방향 레이아웃 수정Vertical 방향 레이아웃을 수정할 때처럼 동일한 방법으로 수정이 가능하다.레이아웃을 LinearLayout으로 변경LinearLayout이란 레이아웃의 View들을 Horizontal 혹은 Vertical 행으로 정렬하는 View Group을 말한다. 보통 다른 View 그룹 간에 UI 구성 요소를 가로 혹은 세로로 정렬하기 위해 자주 사용된다.블록(View)을 차곡차곡 쌓아올리는 것과도 같은 레이아웃인데, 블록을 쌓을 때 블록과 블록 사이가 비어있을 수 없는 것처럼 각 View는 연속적이다. 따라서 객체를 만들면 겹치지 않고 수평 또는 수직으로 나열된다.Required Attributes layout_width layout_height match_parent: 그것의 Parent의 너비나 높이를 가득 채우도록 View를 확장한다. wrap_content: View 크기를 축소해서, View가 내용을 둘러쌀 수 있을 정도로마나 커진다. 내용이 없으면 View가 보이지 않게 된다. Fixed number of dp: 장치 화면 밀도에 맞게 조정된 고정된 사이즈를 지정한다. orientation android:orientation = &quot;~~&quot; horizontal: View가 왼쪽에서 오른쪽으로 정렬된다. 디폴트 값. vertical: View가 위에서 아래로 정렬된다. LinearLayout에서는 View의 가중치(weight)를 설정할 수 있는데, 이 때 가중치란 부모 컨테이너의 남은 영역을 얼마나 차지할 것인가를 결정하는 비율 값이다. 디바이스 별로 화면 크기가 달라도 알맞은 비율을 유지할 수 있다.레이아웃을 RelativeLayout으로 변경RelativeLayout이란 그룹 내에서 각 View가 다른 View들과 상대적으로 배치되고 정렬되는 View Group을 말한다.LinearLayout에 비해 View의 배치가 보다 자유로운데, View들의 상대적인 위치로 배치할 수 있다는 것은 곧 부모 레이아웃에서의 상대적인 위치일 수도 있고, 특정 View에 대한 상대적인 위치일 수도 있다. 즉, 객체를 만들면 객체 혼자 움직이지 않고 항상 id(객체 이름)를 선정한 다른 객체를 기준으로 위치와 방향을 조정한다.정렬부모 레이아웃에서의 상대적인 위치 지정 android:layout_alignParent(Top / Bottom / Left / Right) = ~~: 빈 칸(~~)에 true를 넣어 View를 부모 레이아웃의 한 변에 정렬하여 배치할 수 있다. android:layout_center(Horizontal / Vertical / Inparent) = ~~: 빈 칸에 true를 넣어 View를 부모 레이아웃의 수평 중앙 / 수직 중앙 / 전체 중앙으로 배치할 수 있다.특정 View에 대한 상대적인 위치 지정 android:layout_(above / below / toLeftOf / toRightOf) = @id/~~: 빈 칸에 id를 입력하여, View를 그 id에 해당하는 View의 위 / 아래 / 왼쪽 / 오른쪽에 배치할 수 있다. android:layout_align(Top / Bottom / Left / Right) = @id/~~ 빈 칸에 id를 입력하여, View를 그 id에 해당하는 View의 한 변에 정렬하여 배치할 수 있다.Image Source https://developer.android.com/codelabs/android-training-layout-editor-part-a/img/82bedbd4dd5bef39.png?hl=ko https://developer.android.com/codelabs/android-training-layout-editor-part-a/img/df8aacf0d83e0af7.png?hl=ko https://beomseok95.tistory.com/305#View_%ED%81%AC%EA%B8%B0_-_android:layout_width___layout_height_%EC%86%8D%EC%84%B1_%EC%82%AC%EC%9A%A9 https://developer.android.com/codelabs/android-training-layout-editor-part-b/img/2880bbe9bf5ed4bd.png?hl=koReferences https://developer.android.com/courses/fundamentals-training/toc-v2?hl=ko https://newgenerationkorea.wordpress.com/2015/07/18/layout-%EA%B5%AC%EC%84%B1%ED%95%98%EA%B8%B0-linearlayout%EA%B3%BC-relativelayout/ https://m.blog.naver.com/789_skymert/221973230139" }, { "title": "Android | RecyclerView", "url": "/posts/android-recyclerview/", "categories": "Android", "tags": "android, recyclerview", "date": "2022-04-15 14:35:00 +0900", "snippet": "RecyclerView 개념RecyclerView를 사용하면 대량의 데이터 세트를 효율적으로 표시할 수 있다. RecyclerView는 개별 요소를 재활용하여, 항목이 스크롤되어 화면에서 벗어나더라도 RecyclerView는 뷰를 제거하지 않는다. 대신 스크롤된 새 항목의 뷰를 재사용한다.RecyclerView 활용1. 레이아웃 영역 준비1-1. Main Activity에 RecyclerView 추가Main Activity 등의 자신이 사용할 Activity에 RecyclerView를 추가해준다.1-2. RecyclerView 레이아웃 설정데이터가 어떻게 들어갈 것인지, 그 틀을 정해주어야 한다.2. 모델 생성1-2.에서 생성한 레이아웃을 실제 모델(코드)로 구현한다.3. Adapter 생성Adapter에서는 작성한 RecyclerView 아이템 레이아웃과 데이터를 실제로 연결하는 역할을 수행한다. RecyclerView.Adapter를 상속받아 새로운 Adapter를 만들 때, Override가 필요한 메서드는 다음과 같다.4. RecyclerView에 Adapter와 LayoutManager 지정실제 RecyclerView에 연결해주자. 메서드 설명 onCreateViewHolder(ViewGroup parent, int viewType) viewType 형태의 아이템 뷰를 위한 ViewHolder 객체 생성 onBindViewHolder(ViewHolder holder, int position) position에 해당하는 데이터를 ViewHolder의 아이템뷰에 표시 getItemCount() 전체 아이템 개수를 리턴 Image 출처 https://velog.velcdn.com/images%2Fhoyaho%2Fpost%2F9bbc5c00-4d42-4732-b26c-7a839380cd85%2Fimage.pngReferences https://developer.android.com/guide/topics/ui/layout/recyclerview?hl=ko https://developer.android.com/codelabs/android-training-create-recycler-view?index=..%2F..%2Fandroid-training&amp;amp;hl=ko#0 https://recipes4dev.tistory.com/154 https://velog.io/@hoyaho/RecyclerView" }, { "title": "Android 기초 1.1 시작하기", "url": "/posts/android-basic-1/", "categories": "Android, Fundamentals", "tags": "android, codelab", "date": "2022-04-15 14:35:00 +0900", "snippet": "Android에 관해서는 동아리에서 어느정도 공부했었지만, 체계적으로 기초부터 공부한 게 아니라 중구난방으로 배운 감이 없잖아 있어서 Google에서 제공하는 Codelab을 보면서 다시 공부해보기로 했다.사용할 언어는 Java. 요즘 안드로이드는 Kotlin으로 거의 넘어간 것 같긴 하지만, Java가 익숙한 편이라 우선 Java로 공부하면서 여러 기능을 익혀보고 Kotlin으로 넘어가보려고 한다.Summary 프로젝트에 새로운 Library를 추가하거나 Library 버전을 바꾸기 위해서는 build.grandle (Module:app) 파일을 수정한다. 앱을 위한 모든 코드와 리소스는 app과 res 폴더에 위치한다. java 폴더는 Java 소스 코드 형태의 Activities, Tests, 그리고 다른 Components들을 포함한다. res 폴더는 Layouts, Strings, Images와 같은 리소스를 포함한다. 안드로이드 앱에 Features, Components나 Permissions을 추가하기 위해서는 AndroidManifest.xml을 수정해줘야 한다. 여러 Activities와 같은 앱을 위한 모든 Componenets는 이 XML 파일 안에서 선언되어 있어야 한다.Log앱에 Log statement를 추가하여 Logcat 창에서 메시지를 표시할 수 있다. Log 메시지는 Values, Execution paths, Exceptions을 확인하기 위한 좋은 디버깅 도구이다.다음과 같이 Log를 작성할 수 있다.Log.d(&quot;MainActivity&quot;, &quot;Sample Log Message&quot;); Log: Logcat 창에 로그 메시지를 보내기 위한 클래스 d: 로그 메시지를 필터링하기 위한 디버그 수준 설정 e: Error w: Warn i: Info &quot;MainActivity&quot;: Logcat 창에서 메시지를 필터링하기 위한 첫번째 인자인 TAG 일반적으로 메시지가 발생한 Activity 이름으로 설정해주어 디버깅이 편리하도록 한다. private static final String LOG_TAG = MainActivity.class.getSimpleName(); &quot;Sample Log Message&quot;: 실제 메시지에 해당하는 두번째 인자References https://developer.android.com/courses/fundamentals-training/toc-v2?hl=ko" }, { "title": "Android에서 Flask 서버 접속하기 2 - SwipeRefreshLayout 사용", "url": "/posts/flask-android-2/", "categories": "Android, etc", "tags": "android, flask, volley, json", "date": "2022-04-14 16:55:00 +0900", "snippet": "이전 글에서 Flask 로컬 서버에서 랜덤한 숫자를 발생시키고 해당 숫자를 안드로이드 에뮬레이터에서 받아오는 예제를 진행해보았다.이번에 추가한 내용은 다음과 같다. .json Format의 지정해둔 key 값을 통해 랜덤한 숫자 value만을 받아온다. 이를 안드로이드 앱에서 Random Number: X 형태로 출력한다. ConstraintLayout 대신 SwipeRefreshLayout을 사용하여 당겨서 새로고침 기능을 추가했다. 이를 통해 앱 종료 후 재실행이 아닌 단순 새로고침으로 난수가 계속해서 바뀌는 것을 확인할 수 있다.코드는 이 쪽.Flask(Jupyter notebook, python) 서버 partjupyter notebook에서 실행했다. 이전과 크게 달라진 점은 없으며, value를 string으로 변환하지 않고 랜덤하게 발생한 int값을 그대로 넘긴다.import flaskimport randomapp = flask.Flask(__name__)@app.route(&#39;/&#39;)def make_randomNumber(): ranStr = random.randrange(1, 11) return flask.jsonify({&#39;tk&#39;:ranStr}), 200 if __name__ == &#39;__main__&#39;: app.run(host = &#39;0.0.0.0&#39;)로컬 서버를 구동하고 있는 상태에서 안드로이드 앱을 실행하자. 자꾸 까먹는다.TODOAWS를 이용하여 실제 퍼블릭 서버 배포Android(Android studio, java) 어플리케이션 partonResponse()에서 JSON Object를 받아와 파싱하기 (참고)추가된 코드는 다음과 같다.import org.json.JSONException;import org.json.JSONObject;...public void onResponse(String response) { try { JSONObject jsonObject = new JSONObject(response); ((TextView) findViewById(R.id.tv_test_message)).setText(&quot;Random Number: &quot; + jsonObject.getInt(&quot;tk&quot;)); //python 코드에서 json의 key값을 &#39;tk&#39;로 설정해줬기 때문에 해당 key로 난수 value를 받아온다. } catch (JSONException e) { Toast.makeText(getApplicationContext(), &quot;Err ErrorListener:&quot; + e, Toast.LENGTH_SHORT).show(); }}...SwipeRefreshLayout 사용하기(참고)build.grandle(:app)에 dependency 추가해당 파일의 dependencies{ ... } 부분에 다음 문구를 추가한 뒤 Sync now로 다운로드 받는다.implementation &quot;androidx.swiperefreshlayout:swiperefreshlayout:1.1.0&quot;Activity_main.xml 수정하기우선 activity_main.xml을 수정해줘야한다.Code를 직접 수정해준다. 본래 &amp;lt;androidx.constraintlayout.widget ... &amp;gt;으로 되어있을텐데, 이 부분을 포함하여 Textview의 설정도 ConstraintLayout에서 SwipeRefreshLayout으로 바뀌므로 일부 바꿔준다.본래는 새로고침할 View 영역을 SwipeRefreshLayout으로 감싸줘야 하는데, 내 경우는 textview 하나 있는 거 감싸주는 거라 통째로 고쳐주었다.&amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&amp;gt;&amp;lt;androidx.swiperefreshlayout.widget.SwipeRefreshLayout xmlns:android=&quot;http://schemas.android.com/apk/res/android&quot; xmlns:tools=&quot;http://schemas.android.com/tools&quot; android:id=&quot;@+id/swipeLayout&quot; android:layout_width=&quot;match_parent&quot; android:layout_height=&quot;match_parent&quot; tools:context=&quot;.MainActivity&quot;&amp;gt; &amp;lt;TextView android:id=&quot;@+id/tv_test_message&quot; android:gravity=&quot;center&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Empty Message&quot; android:textSize=&quot;20sp&quot;&amp;gt; &amp;lt;/TextView&amp;gt;&amp;lt;/androidx.swiperefreshlayout.widget.SwipeRefreshLayout&amp;gt;MainActivity.java 수정하기 MainActivity 클래스가 SwipeRefreshLayout.OnRefreshListener 인터페이스를 implement하게 수정 SwipeRefreshLayout을 객체로 생성 onCreate( ... ) 메서드에서 SwipeRefreshLayout에 setOnRefreshListener() 메서드를 통해 리스너를 달아준다. onRefresh() 메서드에서 새로고침 시 변경되는 사항을 작성한다. 해당 메서드에 작성한 내용은 사용자가 화면을 위에서 아래로 당기면 호출된다. SwipeRefreshLayout을 사용해서 새로고침을 구현하는 경우, setRefreshing() 메서드로 화면을 update하고 새로고침이 끝났다면 반드시 setRefreshing() 메서드 인자에 false를 세팅해주어야 한다. (Boolean 값으로 상단 원형 ProgressBar의 Visibility를 설정함)package com.example.flaskservertest;import androidx.appcompat.app.AppCompatActivity;import androidx.swiperefreshlayout.widget.SwipeRefreshLayout;import android.os.Bundle;public class MainActivity extends AppCompatActivity implements SwipeRefreshLayout.OnRefreshListener { SwipeRefreshLayout srl; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); srl = findViewById(R.id.swipeLayout); srl.setOnRefreshListener(this); } @Override public void onRefresh() { updateLayoutView(); srl.setRefreshing(false); } public void updateLayoutView(){ //새로고침 시 실행할 내용 작성 ... }}TODO실제 디바이스에 설치References https://developer.android.com/training/swipe/add-swipe-interface?hl=ko#AddRefreshAction https://infos.tistory.com/4004 https://stickode.tistory.com/20 https://kobbi-reply.tistory.com/28" }, { "title": "Android에서 Flask 서버 접속하기 1 - Emulator", "url": "/posts/flask-android-1/", "categories": "Android, etc", "tags": "computer, android, flask, volley", "date": "2022-04-14 14:30:00 +0900", "snippet": "Flask 로컬 서버에서 랜덤한 숫자를 발생시키고 해당 숫자를 안드로이드 에뮬레이터에서 받아오는 예제를 진행해보았다.최종 목표는 퍼블릭 서버에서, 실제 디바이스에 설치된 앱이 값을 받아오는 것.참고한 코드는 여기.Android에서 volley.Response.Listener를 사용하여 응답이 왔을 때 이를 받아 처리를 등록했다.Volley란?Volley는 Android 앱의 네트워킹을 더 쉽고 빠르게 하는 HTTP 라이브러리이다.아직 나는 네트워크나 각종 웹 프레임워크에 관한 지식이 부족한 편인데, 공식 문서 및 각종 구글링을 통해 알게 된 내용을 정리해놓으려고 한다.Volley로 간단한 요청 보내기공식 문서에서는 RequestQueue를 만들고 Request 객체를 전달하여 Volley를 사용한다.Volley.newRequestQueue 메서드를 사용하여 RequestQueue를 편리하게 설정하고 요청을 전송하는 방법에 관해 코드 레벨로 간단하게 알아보자.(1) 인터넷 권한 추가앱이 네트워크에 연결하기 위해 AndroidManifest.xml에 android.permission.INTERNET 권한을 추가해야 한다.(2) newRequestQueue 사용 final TextView textView = (TextView) findViewById(R.id.text); // ... // RequestQueue를 초기화한다. RequestQueue queue = Volley.newRequestQueue(this); String url =&quot;http://www.google.com&quot;; // 제공된 URL로부터 string response를 요청한다. StringRequest stringRequest = new StringRequest(Request.Method.GET, url, new Response.Listener&amp;lt;String&amp;gt;() { @Override public void onResponse(String response) { // Display the first 500 characters of the response string. textView.setText(&quot;Response is: &quot;+ response.substring(0,500)); } }, new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { textView.setText(&quot;That didn&#39;t work!&quot;); } }); // RequestQueue에 요청을 추가한다. queue.add(stringRequest);실제 구현코드는 이 쪽.다만 나는 여기의 코드를 참고하여 작성했기 때문에, RequestQueue는 이용하지 않았다.Flask 서버에서 발생시킨 난수를 key-value 형태의 .json 파일 형식으로 웹에 띄우면, 그 값을 Android Emulator로 가져와 화면의 textview에서 보여준다.Flask(Jupyter notebook, python) 서버 partjupyter notebook에서 실행했다.import flaskimport randomapp = flask.Flask(__name__)@app.route(&#39;/&#39;)def make_randomNumber(): ranStr = &quot;random number: &quot; + str(random.randrange(1, 11)) # 1에서 10 사이의 랜덤한 숫자를 발생 시킨다 return flask.jsonify({&#39;tk&#39;:ranStr}), 200 ## json 형태로 넘김 if __name__ == &#39;__main__&#39;: app.run(host = &#39;0.0.0.0&#39;)서버를 구동하고 있는 상태에서 안드로이드 앱을 실행하자.Android(Android studio, java) 어플리케이션 part(1-1) 권한 설정AndroidManifest.xml 파일을 열어보자.그러면 보통 다음과 같이 적혀있다.&amp;lt;? ... &amp;gt;&amp;lt;manifest ... &amp;gt; &amp;lt;!-- 여기에 추가 권한을 작성한다. --&amp;gt; &amp;lt;application ... &amp;gt; &amp;lt;activity ... &amp;gt; ... &amp;lt;/activity&amp;gt; &amp;lt;/application&amp;gt;&amp;lt;/manifest&amp;gt;이제 위에 ``을 작성해주자.(1-2) dependency 추가나는 자동으로 됐는데 혹시나 추가가 잘 되었는지 확인해보자.build.grandle(:app) 파일의 dependencies 부분에 아래의 내용이 잘 추가되었는지 확인해본다.implementation &#39;com.android.volley:volley:1.2.1&#39;(2) activity_main.xml에서, flask 서버로부터 내용을 받아와 해당 내용을 보여줄 textview를 하나 만들어 원하는 대로 이름을 설정한다. 나의 경우는 tv_test_message로 설정했다.&amp;lt;TextView android:id=&quot;@+id/tv_test_message&quot; android:layout_width=&quot;wrap_content&quot; android:layout_height=&quot;wrap_content&quot; android:text=&quot;Empty Message&quot; app:layout_constraintBottom_toBottomOf=&quot;parent&quot; app:layout_constraintLeft_toLeftOf=&quot;parent&quot; app:layout_constraintRight_toRightOf=&quot;parent&quot; app:layout_constraintTop_toTopOf=&quot;parent&quot; /&amp;gt;(3) MainActivity.java에서 volley를 사용한 코드를 작성한다.여기서 문제가 발생했었는데, Android Emulator에서 컴퓨터 로컬호스트에 어떤 URL을 통해 접속하는지 알 수 없었다. 이 때문에 여러 에러와 마주쳐야 했다… 우선 Flask 로컬 서버는 일단 컴퓨터에서 127.0.0.1:5000로 돌아간다는 점을 알아두고 가자.일단 구글에 ‘안드로이드 에뮬레이터 로컬 서버 접속’이라고 검색해보면 에뮬레이터에서 ipv4 주소(192.XXX…)로 접속해야 한다, 혹은 로컬 서버 주소(127.XXX…)를 입력해야 한다 이것저것 많이 나왔는데 일단 이 경우는 무조건 아래의 에러를 마주쳐야 했다.NetworkDispatcher.processRequest: Unhandled exception java.lang.RuntimeException: Bad URL ...위의 오류는 여기를 참고해서 해결했다.에뮬레이터의 각 인스턴스는 가상 라우터/방화벽 서비스 뒤에서 실행되어 개발 머신 네트워크 인터페이스 및 설정과 인터넷에서 격리된다. 에뮬레이션된 기기는 네트워크에서 개발 머신이나 다른 에뮬레이터 인스턴스를 볼 수 없다. 대신 이더넷을 통해 라우터/방화벽에 연결되어 있는 것만 볼 수 있다.각 인스턴스의 가상 라우터는 10.0.2/24 네트워크 주소 공간을 관리한다. 라우터가 관리하는 주소는 모두 10.0.2.xx 형식이다. 네트워크 주소 설명 10.0.2.1 라우터/게이트웨이 주소 10.0.2.2 호스트 루프백 인터페이스의 특수 별칭(개발 머신의 127.0.0.1) 10.0.2.3 첫 번째 DNS 서버 10.0.2.4/10.0.2.5/10.0.2.6 두 번째, 세 번째, 네 번째 DNS 서버(선택사항, 있는 경우) 10.0.2.15 에뮬레이션된 기기 네트워크/이더넷 인터페이스 127.0.0.1 에뮬레이션된 기기 루프백 인터페이스 즉, 에뮬레이터에서 로컬 Flask 서버에 접속하기 위해서는 URL에 10.0.2.2:XXXX를 입력해야 한다.그러나 또다른 에러를 마주쳤다.code 400, message Bad request versionJupyter Notebook에서는 다음과 같은 에러를 출력했다.에뮬레이터 크롬에서 https://10.0.2.2:5000를 접속했을 때는 이제 잘 출력돼서 뭐가 문제인건지 또 골치아팠는데 간단하게 해결됐다.위의 오류는 URL을 https://10.0.2.2:5000에서 http://10.0.2.2:5000로 변경해주었더니 해결되었다.최종 코드는 다음과 같다.package com.example.flaskservertest;import androidx.appcompat.app.AppCompatActivity;import android.os.Bundle;import android.widget.TextView;import android.widget.Toast;import com.android.volley.Request;import com.android.volley.RequestQueue;import com.android.volley.Response;import com.android.volley.VolleyError;import com.android.volley.toolbox.StringRequest;import com.android.volley.toolbox.Volley;public class MainActivity extends AppCompatActivity { @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); Response.Listener&amp;lt;String&amp;gt; rplsn = new Response.Listener&amp;lt;String&amp;gt;() { @Override public void onResponse(String response) { ((TextView) findViewById(R.id.tv_test_message)).setText(response.toString()); } }; Response.ErrorListener errlsn = new Response.ErrorListener() { @Override public void onErrorResponse(VolleyError error) { Toast.makeText(MainActivity.this, &quot;Err ErrorListener:&quot; + error.toString(), Toast.LENGTH_SHORT).show(); } }; //String URL = &quot;https://jsonplaceholder.typicode.com/todos/1&quot;; String URL = &quot;http://10.0.2.2:5000&quot;; StringRequest req = new StringRequest(Request.Method.GET, URL, rplsn, errlsn); RequestQueue rq = Volley.newRequestQueue(MainActivity.this); rq.add(req); }}위의 코드는 json 형식으로 파싱하지 않고 그냥 모든 string을 통으로 가져오는 예제이다.json 형식으로 파싱하는 예제는 곧 다시 업로드하려고 한다.일단은 위의 코드를 실행해서 에뮬레이터에 앱을 빌드하면 정상적으로 random number가 출력됨을 볼 수 있다.JSONPlaceholder - typicode(3)번의 java 코드에서 URL에 주석 처리 된 페이지가 있는데, 무료로 가상 REST API를 제공해주는 사이트이다. 테스트 용도로 사용했다.로컬 서버에 접속하기 위해 URL을 10.0.2. ...로 설정해주었지만, 만약 실제 디바이스에서 실제 웹사이트에 접속해서 정보를 받아오려는 경우 주석처리 된 것처럼 URL에 원하는 주소를 입력해주면 된다.TODO 앱을 새로고침해서 Random Number를 출력하기 현재는 종료 후 재접속 시 Random Number가 출력됨 json 형태를 파싱해서 Number만 받아오기 AWS 알아보기 Github 학생 인증 시 AWS 이용이 무료라는 소리를 어디서 들은 것 같아서 같이 알아보기 References https://developer.android.com/training/volley?hl=ko https://developer.android.com/studio/run/emulator-networking.html https://infos.tistory.com/4004 https://stackoverflow.com/questions/49389535/problems-with-flask-and-bad-request" }, { "title": "API란?", "url": "/posts/api/", "categories": "Computer", "tags": "computer, api", "date": "2022-04-10 10:33:00 +0900", "snippet": "API란? Application programming interface 컴퓨터나 컴퓨터 프로그램 사이의 연결 어플리케이션 소프트웨어 및 서비스를 통합하는 툴, 정의, 프로토콜의 세트컴퓨터와 인간을 연결하는 User interface와는 반대로, API는 컴퓨터나 소프트웨어를 서로 연결한다.즉, 최종 사용자에 의해 사용되도록 고안된 것이 아니라 소프트웨어에 이를 통합하고자 하는 컴퓨터 프로그래머가 사용하도록 고안된 것이다.음식점에서 손님(프로그램)에게 주문 가능한 메뉴(명령 목록)를 정리해서 보여주고 손님이 메뉴를 주문(명령)하면 해당 메뉴를 주방(응용 프로그램)에 전달하여 상호작용한 뒤, 주문했던 음식이 나오면 손님에게 다시 전달(프로그램의 명령에 따른 결과값)하는 점원이 API의 역할을 수행한다고 볼 수 있다.(예시) 네이버 Open API 목록Web API란? 웹 서버 또는 웹 브라우저를 위한 API 웹 어플리케이션 개발에서 다른 서비스에 요청을 보내고 응답을 받기 위해 정의된 명세Server sideServer-side Web API는 일반적으로 JSON이나 XML로 표현되는, 정의된 Request-Response 메시지 시스템을 향하는 공개된 Endpoint(하나 혹은 그 이상)로 이루어진 programmtic interface다. 웹을 통해 공개되며, 보통 HTTP 기반 Web server다.EndpointEndpoint는 Server-side Web API와 상호 작용할 때 매우 중요하게 여겨지는데, 타사 소프트웨어에서 액세스 가능한 리소스가 있는 위치를 지정하기 때문이다. 일반적으로 HTTP 요청이 게시되면, 응답이 예상되는 URI를 통해 액세스가 이루어진다.Resources vs. ServicesWeb 2.0 Web API는 종종 REST나 SOAP와 같은 기계 기반 상호작용을 이용한다. RESTful web API: URL 인코딩 매개 변수를 통해 리소스에 접근하는 HTTP 메서드와, JSON 또는 XML을 사용하여 데이터를 전송하는 방식을 기반으로 한다. SOAP protocol: W3C에 의해 표준화된 방법으로, 일반적으로 HTTP를 통해 XML을 Payload 형식으로 이용해야 한다.(REST vs. SOAP에 관한 상세한 설명)Client sideClient-side web API는 웹 브라우저나 다른 HTTP 클라이언트 내에서 기능을 확장하기 위한 programmtic interface다.보통 Plug-in 브라우저 확장의 형태였으나, 최근에는 표준화된 JavaScript 바인딩을 대상으로 한다.References https://ko.wikipedia.org/wiki/API https://en.wikipedia.org/wiki/Web_API https://www.redhat.com/ko/topics/api https://blog.wishket.com/api%EB%9E%80-%EC%89%BD%EA%B2%8C-%EC%84%A4%EB%AA%85-%EA%B7%B8%EB%A6%B0%ED%81%B4%EB%9D%BC%EC%9D%B4%EC%96%B8%ED%8A%B8/" }, { "title": "백준 2447", "url": "/posts/baekjoon2447/", "categories": "Computer, PS", "tags": "baekjoon, ps", "date": "2022-04-05 23:50:00 +0900", "snippet": "요즘 백준 단계별로 풀어보기를 지난 여름에 이어 다시 해보고 있다.코딩 테스트 대비도 할 겸, 굳은 뇌도 풀 겸 하루에 2~3문제 씩 푸는 중이다.지난 여름만 해도 거의 C++로 작성하다가, 데이터베이스시스템 과목을 수강하면서 Java로 n천줄을 짠 뒤로는 거의 Java로 대부분의 코드를 작성하고 있는데, 그래서 백준도 자바로 푸는 중이다.그런데 방금 2447번 문제를 풀었는데, 같은 알고리즘으로 C++은 시간 안에 돌아가지만 자바는 시간 초과가 뜬다.언어 별 차이에 관해서 좀 더 자세하게 알아보는 것도 재밌을 것 같다." }, { "title": "1. 네트워크의 구성", "url": "/posts/computer-network-1/", "categories": "Computer, Network", "tags": "computer, network", "date": "2022-04-01 12:00:00 +0900", "snippet": " 네트워크의 다양한 형태를 이해한다. 통신망 구성의 기본인 네트워크 접속 장치를 이해한다. 네트워크 접속 형태의 종류와 특징을 학습한다. 네트워크 전송 매체의 종류와 특징을 학습한다.01. 네트워크의 형태근거리 네트워크 (LAN)근거리 네트워크(LAN: Local Area Network)란, 가까운 거리에 위치한 컴퓨터의 네트워크를 말한다. 유선 케이블, 적외선 링크, 무선 송수신기 등을 이용하여 통신한다.본 목차에서는 네트워크의 데이터 전송 원리와 서로 다른 유형의 네트워크의 데이터 공유 방법에 관해 공부해볼 것이다. 패킷(Packet): 네트워크를 이용하여 데이터를 한 컴퓨터에서 다른 컴퓨터로 전송하기 위해 작은 그룹으로 분할 된 데이터 전송 단위 패킷은 헤더(Header), 페이로드(Payload), 제어 요소 등을 포함하는 일종의 data segment다. 각 LAN은 특정한 Protocol(데이터를 송수신하는 일련의 규칙)로 운용된다.캠퍼스 네트워크 (CAN)캠퍼스 네트워크(CAN, Campus Area Network)는 LAN보다 더 크고 다양한 규모에서 사용된다.광역 네트워크 (WAN)광역 네트워크(WAN, Wide Area Network)는 두 개 이상의 LAN을 넓은 지역에 걸쳐 연결하는 것을 말한다. 예를 들어, 어떤 기업의 서울 본사와 지방의 생산 공장 간에 데이터와 프로그램을 공유하기 위해 기존 전화선에 라우터를 연결하여 광역 네트워크를 구성하기도 한다.먼 거리로 데이터를 전송하기 위해서는 광역 네트워크를 사용하는데, 보통 데이터 전송 설비를 임대하기에 비용이 많이 든다.인트라넷 (Intranet)인트라넷(Intranet)은 인터넷에서 사용하는 회선과 여러 기반 기술을 이용하여 구축하는 사설 네트워크를 말한다. 예를 들어, 각 지방에 분산된 대학 캠퍼스들을 연결하려고 할 때, 각 캠퍼스에서 가장 가까운 ISP까지만 연결하면 인터넷을 이용하여 저렴한 비용으로 사설 네트워크를 구축할 수 있다.02. 네트워크 접속 장치네트워크 접속 장치는 통신망 구성에서 가장 기본이 되는 하드웨어다. 물리적으로 떨어져 있는 다양한 형태의 근거리 통신망을 연결하여 좀 더 복잡하고 큰 광역 통신망을 형성하기 위해서는 다양한 저복 장치가 필요하다.컴퓨터 네트워크 장치는 Network Interface Card를 이용해서 네트워크에 연결할 수 있다. 또한, 허브, 중계기, 스위치, 게이트웨이, 라우터 등을 이용하여 Networking 문제를 해결한다. (용어 정리 참고)LAN 카드 (NIC, Network Interface Card) 두 대 이상의 컴퓨터로 네트워크를 구성하기 위해 외부 네트워크와 빠른 속도로 데이터를 송수신할 수 있도록 컴퓨터 내에 설치하는 확장 카드 전송 매체에 접속하는 역할과 데이터의 입출력 및 송수신, Protocol의 처리 기능 등을 담당 고유의 식별 코드, MAC 주소(Media Access Control Address): LAN 카드에 할당된 48비트의 물리적 주소허브 (Hub) 여러 대(세 대 이상)의 컴퓨터를 손쉽게 연결하는 장치 여러 개의 입력, 출력 포트가 있는 특수한 형태의 네트워크 장치. 한 포트에서 수신된 신호는 허브의 다른 모든 포트로 즉시 재전송되며, 모든 입력과 출력은 서로 연결되어 있어 여러 개의 노드가 똑같은 중계기를 공유할 수 있도록 해줌. 각 컴퓨터는 이더넷 케이블(UTP)를 사용하여 허브의 각 포트에 연결되고, 한 컴퓨터에서 다른 컴퓨터로 전송되는 컴퓨터가 허브를 통과한다. 허브는 수신되는 데이터의 소스나 의도한 대상을 식별할 수 없으므로 데이터를 보내는 컴퓨터를 비롯해 연결된 모든 컴퓨터에 데이터를 보낸다. Dummy hub 데이터를 네트워크의 다른 컴퓨터로 전송한다. 단순히 컴퓨터 간의 네트워크를 중계하기만 한다.네트워크의 전체 대역폭을 노드 수만큼 분할하여 사용하므로 허브에 연결된 노드 수가 증가하면 네트워크 속도가 느려진다(Network Traffic). Swtching hub 전송 기능을 넘어, 수신지 주소로 switching(수신 측 주소를 읽어 그 주소의 단말기로만 데이터를 보내는 기능)하는 기능이 있고, 노드들을 각각 Point-to-Point로 접속시키므로 네트워크 효율이 높다. Stackable hub 스택 접속 포트가 갖춰진 허브로, 허브와 허브 사이를 연결하여 용량을 확장할 수 있다. 여러 대의 허브가 하나의 허브처럼 동작하므로 전송 속도의 차이가 적다. Intelligent hub 신호의 조절과 변경 등 다양한 지능형 기능을 포함한 허브. Network Managing System을 이용하여 데이터 제어와 분석이 가능하고, 충돌 발생시 충돌을 발생시킨 포트를 강제로 차단시켜 나머지 단말기는 문제 없이 통신이 가능하다. 스위치 (Swtich) 컴퓨터에 할당되는 대역폭을 극대화시켜주는 장치 근거리 통신망이 제공하는 대역폭을 모두 컴퓨터로 전송 수신하는 데이터의 의도한 대상을 식별할 수 있으므로, 데이터를 수신하기로 되어 있는 컴퓨터에만 해당 데이터를 보냄. 동시 송수신도 가능하므로 허브보다 빠른 속도로 데이터를 보낼 수도 있음.브리지 (Bridge) 두 개 이상의 근거리 통신망을 연결하여 하나의 네트워크로 만들어주는 장치 수신지의 주소에 따라 특정 네트워크 트래픽만 통과시킬 수 있도록 설계된 특수한 형태의 네트워크 스위치 전체 네트워크의 트래픽을 줄이기 위해 네트워크를 Segment(하나의 허브나 스위치로 구축된 가장 작은 규모의 네트워크) 단위로 분할게이트웨이 (Gateway) 종류가 다른 두 개 이상의 네트워크를 상호 접속하여 정보를 주고받을 수 있는 장치 LAN, PDN, PSDN 등이 접속할 수 있음 서로 다른 protocol 통신망 간에도 protocol을 변환하여 정보를 주고받을 수 있음중계기 (Repeater) 접속 시스템의 수를 증가시키거나 네트워크 전송 거리를 연장하려고 사용하는 장치 네트워크에서 신호를 수신하여 증폭한 뒤, 다음 구간으로 재전송함라우터 (Router) 서로 다른 네트워크 간에 통신하는 데 사용되는 장치 서로 구조가 다른 망을 연결할 수 있어 LAN, MAN, WAN을 연결하는 데 사용됨 라우팅 기능 수행: IP 주소를 바탕으로 데이터가 수신지까지 갈 수 있는 경로를 선택 오류 패킷 폐기 기능 수행 혼잡 제어 기능 수행03. 네트워크 접속 형태 Network Topology: 네트워크에 연결되어 있는 여러 노드와 링크가 물리적 또는 논리적으로 배치되어 있는 방식 Node: 네트워크에 연결된 주소가 있는 통신 장치(컴퓨터, 프린터, 복합기 등)| Star | Tree | Bus | Ring | Mesh Topology | Hybrid Topology ||——|——|—–|——|—————|—————–|성형 (Star)가장 일반적인 네트워크 구성 형태로, 허브가 네트워크 중앙에 위치하여 다른 모든 노드를 연결한다.중앙의 허브가 회선 교환 방식을 사용하여 통신하려는 노드 두 개에 전용 회선을 만들어 주며, 일대일로 구성되는 점대점의 확장 형태이다.위 그림처럼, 성형 접속의 형태는 메인 프레임이 중앙에 위치하고, 여기에 터미널을 연결한 메인 프레임 시스템1의 모습을 보여준다. 각 장치는 직접적으로 통신할 수 없으며 중앙에 있는 제어 장치인 허브가 교환 역할을 한다.버스형 (Bus)모든 네트워크 노트 및 주변 장치가 파이프 등의 일자형 케이블(Bus)에 연결되어 있는 형태이다. 하나의 긴 케이블이 네트워크의 모든 장치를 연결하는 중추 네트워크 역할을 한다.모든 노드는 하나의 케이블에 연결되어 있고, 케이블의 시작과 끝에는 Terminator2라는 장치를 붙여 신호가 케이블로 돌아오는 것을 막하준다.버스형에서는 케이블에 연결되어 있는 하나의 노드가 전송을 하면 그것이 Broadcast3 되어 다른 모든 노드가 수신할 수 있는데, 연결된 다른 노드들은 이 데이터의 수신 측 주소가 자신에게 보내진 것이면 수신하고, 그렇지 않으면 흘려보낸다. 빠른 속도로 작동하며, 많은 입출력 장치를 신속하게 제어하여 여러 사용자가 함께 이용할 수 있는 컴퓨터 시스템 &amp;#8617; 종단기로, LAN의 전기 신호가 양 끝에서 반사되는 것을 방지하려고 부가하는 장치 &amp;#8617; 하나의 송신 측이 다수의 수신 측 단말을 지정하여 동일한 정보나 메시지를 동시에 전송하는 것 &amp;#8617; " }, { "title": "0. 컴퓨터 네트워크 공부 시작", "url": "/posts/computer-network-0/", "categories": "Computer, Network", "tags": "computer, network", "date": "2022-04-01 11:00:00 +0900", "snippet": "CS 코어 과목 공부를 해두면 좋을 것 같아서, 아직 정규 수업 때 듣지 못했던 컴퓨터 네트워크를 1학기 기간동안 공부해보려고 한다.주교재: 네트워크 개론(2014 개정판) 쉽게 배우는 네트워크의 기본 원리, 진혜진, 한빛 아카데미아직 책을 다 읽어본 것은 아니지만, 3장까지 읽어보았는데 정리가 잘 되어 있고 한글로 설명이 되어 있어서 어느정도 잘 읽히지만 문제가 있었다.나는 네트워크를 아예 처음 공부해보며 이전에 관련 분야에 지식이 많았던 것이 아니기 때문에 네트워크 관련 용어가 생소하게 느껴지는데, 이 책에서는 용어 설명이 자세하게 되어있지 않다. A라는 개념을 설명하기 위해 B라는 단어를 가져와서 설명하는데, B에 관한 설명은 한참 뒤에 나오기도 하고 안나오기도 한다. 나는 배경 지식이 풍부한 편이 아니라서 생소한 단어가 한 줄에 여러번 나오면 읽기 힘들었다.그래서 책을 주로 읽기는 했으나, 다른 문서도 일부 찾아보면서 공부했다. 그때그때 그 글에서만 참고하는 경우에는 해당 글에 참고했다고 남겨놓을 예정이고, 공부하면서 전체적으로 참고한 웹페이지나 자료는 이 글에 계속해서 추가해놓을 예정이다. 네트워크 기초 다지기 네트워크 기본 용어 정리" } ]
